#+TITLE Main Emacs Configuration File
#+AUTHOR Matthew Valentine-House
#+PROPERTY: header-args:emacs-lisp :tangle init.el :mkdirp yes
#+STARTUP overview

* Emacs config - eightbitraptor
:PROPERTIES:
:TOC: :include all
:END:


[[https://user-images.githubusercontent.com/31869/201213452-ad555d25-565d-4550-bffc-c64b00170de4.png]]

This is the latest incarnation of my emacs config. It's been built up, torn
down, refactored and rebuilt many times since I started using Emacs (the
earliest reference I can find is a really ugly screenshot of my work Mac circa
2011 - a long time before I knew remotely what I was doing :|).

:CONTENTS:
- [[#emacs-config---eightbitraptor][Emacs config - eightbitraptor]]
  - [[#introduction][Introduction]]
    - [[#setup-instructions][Setup Instructions]]
  - [[#general-editor-settings][General Editor Settings]]
    - [[#performance-and-startup-optimizations][Performance and Startup Optimizations]]
    - [[#setting-up-the-path][Setting up the PATH]]
    - [[#no-littering][No littering]]
    - [[#fish-mode][Fish mode]]
    - [[#dirvish][Dirvish]]
    - [[#organise-backup-files][Organise backup files]]
    - [[#theming-and-aesthetics][Theming and Aesthetics]]
    - [[#line-lengths][Line Lengths]]
    - [[#mouse-scrolling][Mouse Scrolling]]
    - [[#answer-prompt-questions-faster][Answer prompt questions faster]]
    - [[#ergonomics][Ergonomics]]
    - [[#default-indentation][Default Indentation]]
    - [[#default-selection-behaviour][Default Selection behaviour]]
    - [[#m-q-should-toggle-fill-paragraph][M-q should toggle Fill Paragraph]]
    - [[#configuring-the-gc][Configuring the GC]]
    - [[#undo-tree][Undo Tree.]]
    - [[#crux][Crux]]
    - [[#whitespace-butler][Whitespace Butler]]
  - [[#helper-functions][Helper Functions]]
    - [[#kill-other-buffers-and-focus-the-window][Kill other buffers and focus the window]]
    - [[#duplicate-lines][Duplicate lines]]
    - [[#quickly-change-frame-font-sizes][Quickly change frame font sizes]]
  - [[#keybindings][Keybindings]]
    - [[#custom-functions][Custom functions]]
    - [[#enhanced-navigation][Enhanced Navigation]]
    - [[#remap-m-x][Remap M-x]]
    - [[#resizing-windows][Resizing windows]]
    - [[#maximise-frames][Maximise frames]]
    - [[#delete-frames][Delete frames]]
    - [[#move-between-windows][Move between windows]]
    - [[#which-key-tooltips][Which key tooltips]]
  - [[#navigation-search--project-management][Navigation, Search & Project Management]]
    - [[#ripgrep][Ripgrep]]
    - [[#flx][Flx]]
    - [[#ivy][Ivy]]
    - [[#imenu-list][Imenu-list]]
    - [[#projectile][Projectile]]
    - [[#direnv][Direnv]]
    - [[#editorconfig][Editorconfig]]
  - [[#programming-utilities][Programming Utilities]]
    - [[#company-mode][Company mode]]
    - [[#magit][Magit]]
    - [[#lsp][LSP]]
  - [[#language-modes][Language Modes]]
    - [[#ruby][Ruby]]
    - [[#c][C]]
    - [[#rust][Rust]]
    - [[#r][R]]
    - [[#web-jshtmlcss][Web (js/html/css)]]
    - [[#zig][Zig]]
    - [[#markup-markdowntomlyaml][Markup (Markdown/toml/yaml)]]
  - [[#org-mode][Org Mode]]
    - [[#quick-notes-with-denote][Quick notes (with Denote)]]
    - [[#journal][Journal]]
    - [[#blogging][Blogging]]
  - [[#audio][Audio]]
    - [[#mpd-client][MPD client]]
  - [[#emacs-server][Emacs server]]
:END:


** Introduction

This configuration uses straight.el as a package manager and org babel to
document the configuration. Alongside this file there is also an early-init.el
which Emacs will run before setting up the GUI and before loading any other init
files.

The early-init in this repo does a couple of things:

1. Uses straight.el for packaging. That is:
   - install the latest version of straight.el if it's not already installed
   - disable the built in package.el
   - install use-package and configure it to use straight.el by
     default
2. Install the latest version of org-mode, with no config, just to be able to
   tangle this file.

I install the latest version of org-mode in the early init, to avoid any
compatability problems later on when using straight.el to properly configure org
and some dependencies that I like to use.

*** Setup Instructions

You should be able to clone this repo straight into ~/.emacs.d and start Emacs
and everything will be setup and configured on first start. Although note that
due to a lot of work being done in early-init.el (including loading this file)
the first startup will be very slow as all the packages are git cloned from
their various repositories, but also that _the UI will not be running_

This may make it look like it didn't work, but check in htop/Task
Manager/whatever and you should see the process active and doing stuff and
eventually Emacs will appear. This will only happen on first boot.

I appreciate the UX for this is shit. But it only happens once per machine, and
well; It doesn't really bother me enough to fix it.

** General Editor Settings

*** Performance and Startup Optimizations

Enable package quickstart for faster startup times. This pre-computes package
autoloads and saves them to a file that loads quickly.

#+begin_src emacs-lisp
  ;; Enable package quickstart (must be near the beginning)
  (setq package-quickstart t)

  ;; Ensure straight.el packages can be found
  (eval-when-compile
    (add-to-list 'load-path (expand-file-name "straight/build/" user-emacs-directory)))
#+end_src

*** Tree-sitter Setup

Enable modern Tree-sitter based syntax parsing for better accuracy and performance.
treesit-auto automatically installs Tree-sitter grammars and enables Tree-sitter
modes for supported languages, replacing traditional modes with more precise parsing.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :demand t
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

*** Setting up the PATH

I like to make sure that Emacs is using the same PATH and Ruby paths as my shell
for consistency. This is important on macOS where processes are started with a
different environment.

#+begin_src emacs-lisp
  ;;; init.el --- Main configuration -*- lexical-binding: t; -*-
  (use-package exec-path-from-shell
    :if (memq system-type '(darwin gnu/linux))
    :init (setq exec-path-from-shell-variables '("PATH"
                                                 "MANPATH"
                                                 "GEM_HOME"
                                                 "GEM_PATH"))
          (setq exec-path-from-shell-check-startup-files nil)
          (exec-path-from-shell-initialize))

  (setq frame-resize-pixelwise t)
#+end_src

*** No littering

No littering makes etc and var directories inside .emacs.d and organises all the
files that Emacs and other packages would otherwise just dump directly into
.emacs.d

#+begin_src emacs-lisp
  (use-package no-littering)
#+end_src


*** Fish mode

I use the [[https://fishshell.com/][Fish shell]]. So I install the major mode for editing config
files.

#+begin_src emacs-lisp
  (use-package fish-mode)
#+end_src

*** Dirvish

Is a more fully featured dired mode. Let's try it out for a bit

#+begin_src emacs-lisp
  (use-package dirvish
    :init (dirvish-override-dired-mode))
#+end_src

*** Organise backup files

This block turns off auto save, turns off automatic backups, and sets a backup
directory for any manually created backups to be inside the
~user-emacs-directory~ which is ~.emacs.d~. This avoids littering projects with
lots of ~~~ files, that aren't often gitignored.

#+begin_src emacs-lisp
  (let ((backup-dir (expand-file-name "backup/" user-emacs-directory))
        (autosave-dir (expand-file-name "autosave/" user-emacs-directory)))
    (when (not (file-directory-p autosave-dir))
      (make-directory autosave-dir))
    (when (not (file-directory-p backup-dir))
      (make-directory backup-dir))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir)))
    (setq backup-by-copying t))
#+end_src

*** Theming and Aesthetics

First install solaire-mode, this changes the background colour of "unreal"
buffers - ie. buffers that are not backed by a file. In general use this has the
effect of making files being edited immediately and obviously distinct from
other types of buffers, like dired, treemacs, magit, or the find-file buffer.

This feature is one of the things I really enjoyed, visually, about VSCode

#+begin_src emacs-lisp
  (use-package solaire-mode
    :demand t
    :init (solaire-global-mode +1))
#+end_src

Now set up a theme. We need to choose a theme here that explicitly supports
solaire-mode.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-moonlight :no-confirm))
#+end_src

Then nyan cat as a progress bar in my modeline

#+begin_src emacs-lisp
  (use-package nyan-mode
    :init (nyan-mode))
#+end_src

Silence the audible bell, and make the visual bell quite a bit more subtle -
just flash the text on the modeline white briefly, rather than flashing the
whole window.

#+begin_src emacs-lisp
  (setq ring-bell-function
      (lambda ()
        (let ((orig-fg (face-foreground 'mode-line)))
          (set-face-foreground 'mode-line "#FFFFFF")
          (run-with-idle-timer 0.1 nil
                               (lambda (fg) (set-face-foreground 'mode-line fg))
                               orig-fg))))
#+end_src

I like the cursor to be an I-beam. The toolbars and scrollbars are disabled
in early-init.el for faster startup and a clean looking frame.

#+begin_src emacs-lisp
  (setq-default cursor-type 'bar)
  (toggle-scroll-bar -1)
  (menu-bar-mode 0)
  (tool-bar-mode 0)
#+end_src

Don't display text in the startup buffer or the scratch buffer by default

#+begin_src emacs-lisp
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
#+end_src

Increase the line spacing a little from the default and turn on line numbers
globally.

#+begin_src emacs-lisp
  (setq-default line-spacing 5)
  (global-display-line-numbers-mode t)
#+end_src

Now we'll configure the default fonts. We have to do this per OS because
everything renders fonts differently and at different sizes.

#+begin_src emacs-lisp
  (cond ((eq system-type 'gnu/linux)
         (set-face-attribute 'default nil :font "JetBrains Mono 14"))
        ((eq system-type 'darwin)
         (setq mac-frame-tabbing nil)
         (set-face-attribute 'default nil :font "Jetbrains Mono 16"))
        ((eq system-type 'windows-nt)
         (set-face-attribute 'default nil :font "Consolas 16")))
#+end_src

I spend time manually resizing my Emacs frame ususally when it starts, I usually
want it to just take up roughly 70% of the screen, and be centered, so let's
make it do that. I used this code almost verbatim from here, but had to change
the width calculation to consider multiple monitors used horizontally. This will
always open the initial frame on the Primary monitor.

https://www.reddit.com/r/emacs/comments/9c0a4d/tip_setting_initial_frame_size_and_position/

#+begin_src emacs-lisp
  ;; Set initial frame size and position

  (defun mvh/set-initial-frame ()
    (let* ((base-factor 0.85)
           (primary-monitor-actual-width
            (nth 3 (assoc 'geometry (car (display-monitor-attributes-list)))))
  	 (a-width (* primary-monitor-actual-width base-factor))
           (a-height (* (display-pixel-height) base-factor))
           (a-left (truncate (/ (- primary-monitor-actual-width a-width) 2)))
  	 (a-top (truncate (/ (- (display-pixel-height) a-height) 2))))
      (set-frame-position (selected-frame) a-left a-top)
      (set-frame-size (selected-frame) (truncate a-width)  (truncate a-height) t)))
  (setq frame-resize-pixelwise t)
  (mvh/set-initial-frame)
#+end_src


*** Line Lengths

Break all long lines automatically at ~fill-column~ so I don't have to press
~M-q~ all the time. And then set ~fill-column~ to 80 chars, because 70 is a bit short.

Because I enable ~auto-fill-mode~ I also provide a convenience
function, bound to ~C-c u~ to unfill any paragrahs that get broken
when I don't want them to be.

#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

  (defun unfill-paragraph ()
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))
  (global-set-key (kbd "C-u") 'unfill-paragraph)
#+end_src

Also enable a vertical ruler at 80 columns using
~display-fill-column-indicator-mode~ everywhere.

#+begin_src emacs-lisp
  (global-display-fill-column-indicator-mode)
#+end_src

*** Mouse Scrolling

This controls how many lines the mouse wheel scrolls by.

#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
#+end_src

#+begin_src emacs-lisp
  (use-package beacon
    :config (beacon-mode 1))
#+end_src

*** Answer prompt questions faster

Use y/n in prompts instead of having to explicitly type yes or no

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Ergonomics

I always used to smash these keys accidentally and they'd do random
stuff. I was bad at typing!

I don't think I've had this problem since I changed to using split
ergo keyboards, so I'm not sure whether it's still relevant or
not. At some point I'll get around to testing that...

#+begin_src emacs-lisp
  (when window-system
    ((lambda ()
       (global-unset-key "\C-z")
       (global-unset-key "\C-x\C-z"))))
#+end_src

Also enable Auto-revert mode globally. I do a lot of stuff on the command line
and in other tools, it's nice to not have to get hit with the prompt when I
switch back to Emacs and try to edit something.

#+begin_src emacs-lisp
  (setq global-auto-revert-mode 1)
#+end_src

*** Default Indentation

Default to 4 spaces as an indent everywhere. Obviously other modes are
going to override this as necessary, but I like a 4 space indent
generally.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default c-basic-offset 4)
#+end_src

*** Default Selection behaviour

And turn on ~delete-selection-mode~. This makes emacs visual selection behave
much more like "modern" editors. ie. when you select stuff and start typing your
text will _replace_ the selected text, and you can highlight text and then hit
backspace to delete it.

Without this minor mode enabled Emacs will start inserting text wherever the
point is located (often at the end of the selection), and not actually remove
the seletion.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

*** M-q should toggle Fill Paragraph

#+begin_src emacs-lisp
  (use-package unfill
    :bind ([remap fill-paragraph] . unfill-toggle))
#+end_src

*** Configuring the GC

GC settings are now optimized in early-init.el for better startup performance.
These values are restored after init to reasonable runtime values.

#+begin_src emacs-lisp
  ;; GC settings moved to early-init.el for better startup performance
  ;; Runtime values are set in emacs-startup-hook
#+end_src

*** Undo Tree.

This package is magical, it lets you see the entire edit history of
your file as a tree instead of a linear series of changes. It also
provides a way of visualising the tree, so you can get back basically
any change you make while editing a file.

#+begin_src emacs-lisp
    (use-package undo-tree
      :init (setq undo-tree-auto-save-history nil
                  undo-tree-history-directory-alist '("~/.emacs.d/autosave/"))

      :config (global-undo-tree-mode))
#+end_src

*** Crux

Crux really is a collection of really useful extensions! The ones I
like are:

- ~crux-move-beginning-of-line~ bounces between the first non
  whitespace char in the line and the actual beginning of the line
- ~crux-smart-open-line-above~ Inserts a new line above the point and
  indents it according to the context. Basically the same as ~O~ in
  Vim.
- ~crux-smart-kill-line~ kills from the point to the end of the line,
  then when pressed again, kills the rest of the line. Just means I
  can usually hit ~C-k~ twice instead of ~C-a C-k~ which is quicker.

#+begin_src emacs-lisp
  (use-package crux
    :bind (("C-a" . crux-move-beginning-of-line)
           ("C-o" . crux-smart-open-line-above)
           ("C-k" . crux-smart-kill-line)))

#+end_src

*** Whitespace Butler

Makes sure I don't accidentally commit loads of bad whitespace.

#+begin_src emacs-lisp
  (use-package ws-butler
    :init (setq ws-butler-keep-whitespace-before-point nil)
    (ws-butler-global-mode))
#+end_src

** Helper Functions

A few things that I've found useful over the years. They should
already be pretty well documented - just checkout the function
documentation.

*** Kill other buffers and focus the window

#+begin_src emacs-lisp
  (defun kill-other-buffers ()
    "Make the current buffer the only focus, and kill other buffers
  that are associated with files."
    (interactive)
    (delete-other-windows)
    (mapc 'kill-buffer
          (delq (current-buffer)
                (remove nil (mapcar #'(lambda (b) (when (buffer-file-name b) b))
                                    (buffer-list))))))

#+end_src

*** Duplicate lines

#+begin_src emacs-lisp
  (defun duplicate-line (arg)
    "Duplicate current line, leaving point in lower line."
    (interactive "*p")
    ;; save the point for undo
    (setq buffer-undo-list (cons (point) buffer-undo-list))
    ;; local variables for start and end of line
    (let ((bol (save-excursion (beginning-of-line) (point)))
          eol)
      (save-excursion
        ;; don't use forward-line for this, because you would have
        ;; to check whether you are at the end of the buffer
        (end-of-line)
        (setq eol (point))

        ;; store the line and disable the recording of undo information
        (let ((line (buffer-substring bol eol))
              (buffer-undo-list t)
              (count arg))
          ;; insert the line arg times
          (while (> count 0)
            (newline)         ;; because there is no newline in 'line'
            (insert line)
            (setq count (1- count)))
          )

        ;; create the undo information
        (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
      ) ; end-of-let

    ;; put the point in the lowest line and return
    (forward-line arg))
#+end_src

*** Quickly change frame font sizes

Useful when sharing my screen on a vidoe call so the font can be
legible on the recording.

#+begin_src emacs-lisp
  (defun my-alter-frame-font-size (fn)
    (let* ((current-font-name (frame-parameter nil 'font))
           (decomposed-font-name (x-decompose-font-name current-font-name))
           (font-size (string-to-number (aref decomposed-font-name 5))))
      (aset decomposed-font-name 5 (number-to-string (funcall fn font-size)))
      (set-frame-font (x-compose-font-name decomposed-font-name))))

  (defun my-inc-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1+))

  (defun my-dec-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1-))
#+end_src

** Keybindings

*** Custom functions

First map some of the aformentioned custom functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-d") 'duplicate-line)
  (global-set-key (kbd "C-+") 'my-inc-frame-font-size)
  (global-set-key (kbd "C-=") 'my-inc-frame-font-size)
  (global-set-key (kbd "C--") 'my-dec-frame-font-size)
#+end_src

*** Enhanced Navigation

Add standard Emacs navigation bindings for better call stack navigation.
These work alongside the existing M-t/M-T fuzzy search setup.

#+begin_src emacs-lisp
  ;; Standard xref navigation bindings
  (global-set-key (kbd "M-.") 'xref-find-definitions)     ; Go to definition
  (global-set-key (kbd "M-,") 'xref-go-back)             ; Go back in stack
  (global-set-key (kbd "M-?") 'xref-find-references)     ; Find references
  (global-set-key (kbd "C-M-.") 'xref-find-apropos)      ; Find symbols matching pattern

  ;; Additional navigation helpers
  (global-set-key (kbd "C-M-,") 'xref-go-forward)        ; Go forward in stack (if available)
#+end_src

*** Remap M-x

This is something I learned from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's excellent blog post
about effective Emacs]] - Use a key combo for ~M-x~ that doesn't
involve the ~Alt~ key as it's non standard across environments and
requires some weird hand scrunching to type properly.

I also like ~C-x C-m~ as it has as kind of tempo to it (command
sequences having tempo is a really nice idea I learned about in [[https://www.masteringemacs.org/][Mickey
Peterson's Mastering Emacs book]] back in the day.

#+begin_src emacs-lisp
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
#+end_src

*** Resizing windows

Some keybindings for resizing Windows. I can't remember when I last
used these but you know I'd need them if I ever got rid of them so
here they are.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<left>")  'shrink-window-horizontally)
  (global-set-key (kbd "s-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "s-<up>")    'enlarge-window)
  (global-set-key (kbd "s-<down>")  'shrink-window)
#+end_src

*** Maximise frames

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)
#+end_src

*** Delete frames

With Emacs server running

#+begin_src emacs-lisp
  (global-set-key (kbd "M-âˆ‘") 'delete-frame)
#+end_src

*** Move between windows

Enable windmove keybingings. This slightly arcanely named setting
means you can move between windows with ~shift-u/d/l/r~ rather than
cycling through with ~C-x o~ or the mouse.

#+begin_src emacs-lisp
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
#+end_src

*** Which key tooltips

This package pops up a buffer containing all possible key combinations
if you hit the start of a chord. I hope to one day not need this, but
it's stupidly useful when using stuff I don't normally use everyday.

I've set the delay to be quite long at 3s, just to make sure it
doesn't get in my way when I'm doing normal things.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 1  ; Load 1 second after startup
    :config (which-key-mode)
            (setq which-key-idle-delay 3))

#+end_src

** Navigation, Search & Project Management

*** Ripgrep

for fast project searches, relies on the ~rg~ binary being somewhere
on your path.

#+begin_src emacs-lisp
  (use-package ripgrep
    :defer t)
#+end_src

*** Flx

Not actually sure why this is here. It does fuzzy matching, but I
think it's either pulled in as a dep of something or I don't use it
anymore.

#+begin_src emacs-lisp
  (use-package flx
    :defer t)
#+end_src

*** Ivy

Ivy is a completion framework. So when you search for stuff it'll help
you narrow down onto the result that you're looking for.

A nice write-up about it lives [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][here]]. And the manual is [[https://oremacs.com/swiper/][here]].

I use it in conjunction with ~ivy-rich~ which makes the UI column
based to show more information.

I also use it in conjunction with ~xref~ so that when I do things like
jumping between functions or searching for functions in source code, I
get a nice looking list of functions and meta data about them and can
narrow down on the one I want.

#+begin_src emacs-lisp
  (use-package ivy-rich)
  (use-package counsel)

  (use-package ivy
    :init (setq ivy-use-virtual-buffers t
                ivy-sort-matches-functions-alist '((t . nil)
                                                   (ivy-completion-in-region . ivy--shorter-matches-first)
                                                   (execute-extended-command . ivy--shorter-matches-first)
                                                   (ivy-switch-buffer . ivy-sort-function-buffer)))
    (ivy-mode 1)
    (ivy-rich-mode 1))
#+end_src

I cargo-culted this init section from somewhere and I can't remember
what it fixes anymore. This is now handled in the LSP section.

*** Imenu-list

This is the most lightweight equivalent of Vim's [[https://github.com/preservim/tagbar][Tagbar plugin]] that I
could find. It uses ~imenu-mode~ to breakdown a source file and show
you a list of Classes, structures functions and whatnot in a vertical
bar on the right of the frame.

Fair warning though. It seems to crap itself in ~org-mode~.

While we're here let's configure ~M-t~ to use trigger imenu.

#+begin_src emacs-lisp
  (use-package imenu-list
    :bind ("C-c C-t" . imenu-list-smart-toggle))
  (global-set-key (kbd "M-t") 'imenu)
#+end_src

*** Projectile

#+begin_src emacs-lisp
  ;; Projectile spins trying to calculate what to write in the modeline when using TRAMP.
  ;; forcing a static modeline causes tramp mode to get fast again
  (use-package projectile
    :config (setq projectile-dynamic-mode-line nil)
    (projectile-mode +1)
    :bind-keymap ("C-c p" . projectile-command-map)
    :bind (("M-o" . projectile-find-file)
           ("C-S-g" . projectile-grep))
    :init (setq projectile-completion-system 'ivy))

  (use-package ag
    :defer t)

  (use-package projectile-rails
    :defer t
    :config (projectile-rails-global-mode t))
  (use-package projectile-ripgrep
    :defer t)
#+end_src

*** Direnv

Direnv is heckin useful, I use it everywhere! You need the binary
installed and set up in your shell, but then you can create a ~.envrc~
file in a directory, export shell variables in it, and they're only
applied when you're in that directory.

I use it mainly for setting cflags on various projects.

#+begin_src emacs-lisp
  (use-package direnv
    :init (direnv-mode))
#+end_src

*** Editorconfig

Support the ubiquitous ~.editorconfig~ files that keep cropping up all
over the place.

Personally I'm a little uncomfortable about other people having
control over my editor settings, but there's no doubt they are
useful. And we use them at work, so I guess I'll just deal with it.

#+begin_src emacs-lisp
  (use-package editorconfig
    :init (editorconfig-mode 1))
#+end_src

** Programming Utilities

*** Company mode

Company mode handles intelligent auto-completion with LSP integration.
The configuration prioritizes LSP completions via completion-at-point-functions (capf),
provides tab-triggered completion with fallback to indentation, and includes
performance optimizations. Company-box enhances the UI with icons and better
visual presentation of completion candidates.

#+begin_src emacs-lisp
      (use-package company
        :init (setq company-dabbrev-downcase nil
                    company-idle-delay 0.2  ; Small delay for better performance
                    company-minimum-prefix-length 2  ; Don't complete single chars
                    company-dabbrev-ignore-case 1
                    ;; Prioritize LSP completions via capf, with fallbacks
                    company-backends '((company-capf company-dabbrev-code) company-dabbrev))
        :hook (prog-mode . company-mode)
        :config
        ;; Tab completion with fallback to indentation
        (defun tab-or-complete ()
          "Complete if company is active, otherwise indent."
          (interactive)
          (if (company-manual-begin)
              (company-complete-selection)
            (indent-for-tab-command)))

        ;; Bind tab for completion selection when company is active
        (define-key company-active-map (kbd "TAB") 'company-complete-selection)
        (define-key company-active-map (kbd "<tab>") 'company-complete-selection)

        ;; Global tab binding for when company isn't active
        (global-set-key (kbd "TAB") 'tab-or-complete))

      (use-package company-box
        :hook (company-mode . company-box-mode)
        :init (setq company-box-show-single-candidate t
                    company-box-max-candidates 10  ; Limit candidates for performance
                    company-tooltip-align-annotations t))

#+end_src

*** Magit

Magit mode is, imo, Emacs killer feature. Or at least on of the top
ones. It's an amazing way of interacting with Git.

No config to really note - I've set the magit status window to take up
the whole frame, because when I context switch into Git mode I like to
focus fully on it.

I've also enabled ~vc-follow-symlinks~ which helps out if you ever try
and edit a symlink pointing to a file under source control, by
following the link and opening the original file in Emacs.

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
  ;; Declare function to avoid warnings
  (declare-function magit-display-buffer-fullframe-status-v1 "magit")

  (use-package magit
    :defer t
    :init (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (setq magit-push-current-set-remote-if-missing nil)
    :bind ("C-c s" . magit-status))
#+end_src

*** LSP

LSP configuration provides intelligent IDE-like features across multiple languages
(C, Ruby, and Rust). The configuration optimizes for performance with reasonable
delays, enables intelligent completion via completion-at-point-functions, and
includes signature help for function parameters.

Navigation works on multiple levels: ~M-t~ for buffer-scope symbol search via imenu,
~M-T~ for project-wide workspace symbols, and standard Emacs bindings (~M-.~ for
go-to-definition, ~M-,~ for go-back) for call stack navigation. This creates a
comprehensive code navigation system that scales from buffer to project scope.

#+begin_src emacs-lisp

  (use-package flycheck)

  (use-package lsp-mode
    :config (setq lsp-idle-delay 0.3  ; More reasonable delay for better performance
                  lsp-headerline-breadcrumb-enable nil
                  lsp-enable-on-type-formatting nil
                  lsp-enable-indentation nil
                  lsp-solargraph-formatting nil
                  lsp-eldoc-enable-hover nil
                  lsp-enable-snippets nil
                  ;; Optimize completion settings
                  lsp-completion-provider :capf
                  lsp-completion-enable t
                  lsp-completion-show-detail t
                  lsp-completion-show-kind t
                  ;; Enable signature help for function parameters
                  lsp-signature-auto-activate t
                  lsp-signature-render-documentation nil  ; Keep signatures concise
                  ;; Language server specific settings
                  lsp-rust-analyzer-cargo-watch-command "clippy"
                  lsp-rust-analyzer-server-display-inlay-hints t
                  lsp-enabled-clients '(clangd
                                        ruby-lsp-ls
                                        rust-analyzer)
                  lsp-clients-clangd-args '("--header-insertion=never"
                                            "--all-scopes-completion"
                                            "--background-index"))
    :hook ((c-mode . lsp)
           (c++-mode . lsp)
           (ruby-ts-mode . lsp)
           (rustic-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :bind (("<mouse-4>" . lsp-find-definition)
           ("S-<down-mouse-1>" . lsp-find-definition)
           ("S-<down-mouse-2>" . lsp-find-references)
           ("<mouse-5>" . xref-go-back)
           ("<f12>" . lsp-find-references)
           ("s-'" . xref-go-back))
    :bind-keymap ("C-c l" . lsp-command-map))

  (use-package lsp-ivy
    :bind ("M-T" . 'lsp-ivy-workspace-symbol)
    :config (advice-add 'lsp-ivy--goto-symbol :before
                        (lambda (arg)
                          (xref-push-marker-stack)))
    (advice-add 'lsp-find-definition :before (lambda () (xref-push-marker-stack))))

  (use-package ivy-xref
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))


  (use-package lsp-ui
    :config (setq lsp-ui-sideline-mode nil
                  lsp-ui-flycheck-live-reporting nil
                  lsp-ui-sideline-enable nil
                  lsp-ui-sideline-show-diagnostics nil
                  ;; Enable useful doc features while keeping UI clean
                  lsp-ui-doc-enable t
                  lsp-ui-doc-show-with-cursor nil     ; Don't show on cursor hover
                  lsp-ui-doc-show-with-mouse t        ; Show on mouse hover
                  lsp-ui-doc-delay 0.5                ; Small delay for docs
                  lsp-ui-doc-max-height 20            ; Reasonable doc window size
                  lsp-ui-doc-max-width 80
                  ;; Peek window settings
                  lsp-ui-peek-always-show t
                  lsp-ui-peek-list-width 40
                  lsp-ui-peek-peek-height 15)
    :bind (:map
           lsp-mode-map
           ([remap xref-find-definitions] . #'lsp-ui-peek-find-definitions)
           ([remap xref-find-references] . #'lsp-ui-peek-find-references)
           ;; Additional useful bindings
           ("C-c l d" . #'lsp-ui-doc-show)         ; Show docs on demand
           ("C-c l i" . #'lsp-ui-imenu)))           ; LSP imenu
#+end_src

While we're on ~xref~ and stuff. Let's also make is so that searching
adds the point we're left on to the xref stack.

#+begin_src emacs-lisp
  (advice-add 'isearch-forward :before (lambda (arg1 arg2) (xref-push-marker-stack)))
  (advice-add 'isearch-backward :before (lambda (arg1 arg2) (xref-push-marker-stack)))
#+end_src

** Language Modes

*** Ruby

Some of the codebases I use often require frozen strings. So this convenience
function will add the magic header if it's not already there.

#+begin_src emacs-lisp
  (use-package chruby)

  (defun ruby-frozen-string-literal ()
    "Check the current buffer for the magic comment # frozen_string_literal: true.
  If the comment doesn't exist, offer to insert it."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (unless (string= (thing-at-point 'line)
                       "# frozen_string_literal: true\n")
        (insert "# frozen_string_literal: true\n\n"))))
#+end_src

I prefer to use rbenv to manage my Ruby versions, in conjunction with
ruby-build. rbenv is pretty easy to understand, and whilst I'm not wild about
the shims, it is working well for me. Work however, are all in on
chruby and some of the bits of software I need to integrate with
require it.

So I'll use chruby mode when I have to, on my Shopify machine, and
rbenv everywhere else

I also use minitest for testing.

#+begin_src emacs-lisp
  (if (string-match "Shopify" (system-name))
      (use-package chruby
        :init (chruby "3.3.0"))
    (use-package rbenv
        :init (global-rbenv-mode)
        (rbenv-use-global)))

    (use-package minitest :ensure t)
#+end_src

Ruby support is now handled by Tree-sitter via ruby-ts-mode, which provides
superior syntax parsing and highlighting compared to traditional regex-based modes.
treesit-auto automatically activates ruby-ts-mode for Ruby files and installs
the required Tree-sitter grammar on first use.

#+begin_src emacs-lisp
  ;; Configure Ruby Tree-sitter mode with equivalent functionality to enh-ruby-mode
  (use-package ruby-ts-mode
    :hook (ruby-ts-mode . subword-mode)
    :config
    ;; Disable encoding magic comments (equivalent to enh-ruby-add-encoding-comment-on-save nil)
    (setq ruby-insert-encoding-magic-comment nil)

    ;; Set hanging brace indent level (equivalent to enh-ruby-hanging-brace-indent-level 2)
    (setq ruby-method-params-indent 2)

    ;; Enable case-insensitive search in Ruby buffers
    (add-hook 'ruby-ts-mode-hook (lambda () (setq case-fold-search t)))

    ;; Configure indentation preferences
    (setq ruby-indent-level 2)
    (setq ruby-indent-tabs-mode nil)
    (setq ruby-align-chained-calls t)
    (setq ruby-deep-indent-paren nil) ; Start with shallow indenting

    ;; Implement enh-ruby-bounce-deep-indent equivalent for ruby-ts-mode
    (defun ruby-ts-bounce-deep-indent ()
      "Toggle between deep and shallow indentation styles, similar to enh-ruby-bounce-deep-indent."
      (interactive)
      (let ((col (current-column)))
        (setq ruby-deep-indent-paren (not ruby-deep-indent-paren)
              ruby-deep-indent-paren-style (and ruby-deep-indent-paren 'opening))
        (message "Ruby: Using %s indentation"
                 (if ruby-deep-indent-paren "deep" "shallow"))
        (save-excursion
          (beginning-of-line)
          (delete-horizontal-space)
          (ruby-indent-line))
        (move-to-column col)))

    ;; Override TAB in ruby-ts-mode to include bounce functionality
    (defun ruby-ts-tab-or-bounce ()
      "Indent line, or toggle indentation style if already indented."
      (interactive)
      (if (= (current-indentation)
             (or (save-excursion
                   (beginning-of-line)
                   (ruby-calculate-indent)) 0))
          (ruby-ts-bounce-deep-indent)
        (ruby-indent-line)))

    ;; Bind TAB to our bounce function in ruby-ts-mode
    (define-key ruby-ts-mode-map (kbd "TAB") 'ruby-ts-tab-or-bounce))
#+end_src

Tree-sitter provides more accurate indentation and syntax highlighting than
the previous enh-ruby-mode, with better performance through incremental parsing.
The custom `ruby-ts-bounce-deep-indent` function replicates the enh-ruby-mode
bounce functionality, allowing you to toggle between deep and shallow indentation
styles with TAB when a line is already properly indented.

**Deep indentation** (ruby-deep-indent-paren = t):
```ruby
test_var = if condition
             "yes"
           else
             "no"
           end
```

**Shallow indentation** (ruby-deep-indent-paren = nil):
```ruby
test_var = if condition
  "yes"
else
  "no"
end
```

*** C

The Ruby core team maintain an emacs style mode inside the main CRuby source
tree to help format the Ruby codebase according to their programming style
(which as far as I can tell is a mix of K&R and GNU).

If I have a Ruby checkout in the standard place I keep my source files, then we
should require the ruby-style file.

#+begin_src emacs-lisp
  (let ((ruby-misc-dir "~/git/ruby/misc"))
    (if (file-directory-p ruby-misc-dir)
        (progn
          (add-to-list 'load-path ruby-misc-dir)
          (require 'ruby-style))))
#+end_src

Also add a hook to ~cc-mode~ that sets up the comment/uncomment toggle
shortcut key, because by default it's bound to comment region only and
there's no shortcut for uncommenting a region, which is bonkers.

#+begin_src emacs-lisp
  (defun mvh/prog-mode-hook ()
    (define-key c-mode-map (kbd "C-c C-c") 'comment-or-uncomment-region))
  (add-hook 'c-initialization-hook 'mvh/prog-mode-hook)
#+end_src

#+begin_src emacs-lisp
  (defun cruby/compile-command ()
    "Returns a String representing the compile command to run for the given context"
    "make miniruby")

  (defun cruby/test-command ()
    "Returns a String representing the test command to run for the given context"
    (cond
     ((eq major-mode 'c-mode) "make btest")
     ((eq major-mode 'ruby-ts-mode)
      (format "make test-all TESTS=\"%s\"" (buffer-file-name)))
     ))

  ;; Declare function to avoid warnings
  (declare-function projectile-register-project-type "projectile")

  ;; Register project type after projectile is loaded
  (with-eval-after-load 'projectile
    (projectile-register-project-type 'cruby '("ruby.c" "kernel.rb" "yjit.c" )
                                      :compile 'cruby/compile-command
                                      :test 'cruby/test-command))

(use-package meson-mode)
#+end_src

*** Rust

- [ ] Remove or explain the cargo-culted rustic-mode-hook

This section sets up defaults for programming in Rust. I'm using
rustic-mode. With a few keybindings to tie in to specific functions in lsp-mode
(defined further up).

Most of the useful stuff is actually defined in the lsp-mode section.

#+begin_src emacs-lisp
  (use-package rustic
    :bind (:map rustic-mode-map
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c s" . lsp-rust-analyzer-status))
    :config (setq lsp-enable-symbol-highlighting nil
                  lsp-signature-auto-activate nil
                  rustic-format-on-save nil)
            (add-hook 'rustic-mode-hook 'mvh/rustic-mode-hook))

  (defun mvh/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but
    ;; don't try to save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved
    ;; this should no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t)))
#+end_src

*** R

I use R generally for a bit of light stats munging. These days its mostly taking
benchmark results of perf numbers of the Ruby VM and visualising them.

#+begin_src emacs-lisp
  (use-package ess
    :defer t)
#+end_src

*** Web (js/html/css)

I don't do much web stuff anymore so this may not be the most up to date way of
handling this. I basically just bring in web-mode by default for a bunch of
files that look a lot like they could be web adjacent and configure a consistent
4 space indent.

#+begin_src emacs-lisp
  (use-package web-mode
    :mode "\\.tsx"
          "\\.erb"
          "\\.jsx"
          "\\.html"
          "\\.css"
          "\\.scss"
          "\\.sass"
    :init (setq web-mode-markup-indent-offset 2)
          (setq web-mode-css-indent-offset 2)
          (setq web-mode-code-indent-offset 2)
          (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
          (setq web-mode-enable-auto-indentation 1))
#+end_src

*** Zig

An experiment with Zig.

#+begin_src emacs-lisp
  (use-package zig-mode
    :defer t)
#+end_src

*** Markup (Markdown/toml/yaml)

Import the packages and associate the right file types required to write content
in Markdown, Toml and Yaml.

I also configure a default stylesheet here for previewing Markdown documents in
HTML. Leaving everything up to the browser really doesn't do our documents any
favours.

#+begin_src emacs-lisp

  (setq markdown-preview-stylesheets
        (list "http://thomasf.github.io/solarized-css/solarized-light.min.css"))

  (use-package toml-mode
    :mode "\\.toml")

  (use-package yaml-mode
    :mode "\\.yml"
          "\\.yaml")

  (use-package markdown-mode
    :mode "\\.md"
          "\\.markdown")

#+end_src

** Org Mode

The org mode package has already been installed from the package repos in the
early-init file, so that we could use the latest version to tangle this file
into the standard init file init.el.

Org mode is then specified again here, so that we can define some more thorough
initialisation on the package and set some custom variables.

The main ones defined here are the shift hooks. Setting these to the windmove
functions, means that org-mode window switching behaviour is much more
consistent with the rest of my emacs, which also has windmove enabled.

Now I can move windows with shift+arrows no matter the buffer type

#+begin_src emacs-lisp
    (use-package org-make-toc
      :hook org-mode)
    (use-package org
      :config (setq org-startup-truncated 1
                    org-log-done 1)
              (add-to-list 'org-modules 'org-tempo t)

              (add-hook 'org-shiftup-final-hook 'windmove-up)
              (add-hook 'org-shiftleft-final-hook 'windmove-left)
              (add-hook 'org-shiftdown-final-hook 'windmove-down)
              (add-hook 'org-shiftright-final-hook 'windmove-right)

              (org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)
                                                                       (emacs-lisp . t)
                                                                       (C . t)))
      :mode ("\\.org" . org-mode))
#+end_src

*** Quick notes (with Denote)

I often use the Apple Notes app to take super fast notes on stuff,
that I can look back on later, snippets of debug commands and whatnot.

I'd like to use Emacs to do this so I don't have to leave the editor
so I'm testing out ~denote~.

#+begin_src emacs-lisp
  (use-package denote
    :custom (denote-directory "~/git/notes/misc")
    :bind ("C-x C-n" . denote))
#+end_src

*** Journal

I also use org-journal to document my days. It's configured to start a new
journal file per day in a folder in my home directory.

Each new entry in the same day gets a new timestamped org mode heading in that
file.

#+begin_src emacs-lisp
    (use-package org-journal
      :defer t
      :init (setq org-journal-prefix-key "C-c j ")
      :custom (org-journal-dir "~/git/notes/log_book/")
              (org-journal-file-format "%Y/%m/%d")
              (org-journal-date-format "%A %d %b %Y")
              (org-agenda-files "~/Documents/org/"))
#+end_src

*** Blogging

The following section is an experiment to see whether I can configure and live
with a staticly generated blog/website entirely done within Emacs.

Currently my homepage uses Hugo and the process required to push a new post has
a high enough barrier to entry that I forget it every time, and it makes me want
to post less.

This is still **in progress**

#+begin_src emacs-lisp
  (use-package org-static-blog
    :defer t
    :init
    (setq org-static-blog-use-preview t
          org-static-blog-preview-convert-titles t
          org-static-blog-preview-ellipsis "..."
          org-static-blog-enable-tags t
          org-static-blog-publish-url "http://localhost:9090/"
          org-static-blog-publish-title "eightbitraptor.com"
          org-static-blog-posts-directory "~/src/org-blog/org/posts"
          org-static-blog-drafts-directory "~/src/org-blog/org/drafts/"
          org-static-blog-publish-directory "~/src/org-blog/")

    (setq org-static-blog-page-header
          (concat
           "<meta name=\"author\" content=\"eightbitraptor\">"
           "<meta name=\"referrer\" content=\"no-referrer\">"
           "<link href= \"/static/style.css\" rel=\"stylesheet\"
                  type=\"text/css\" />"
           "<link rel=\"icon\" href=\"static/favicon.ico\">")

          org-static-blog-page-preamble
          (concat
           "<div class=\"header\">"
           "  <a href=\"https://www.eightbitraptor.com\">eightbitraptor.com</a>"
           "  <div class=\"sitelinks\">"
           "    <a href=\"/blog/about.html\">about</a>"
           "    | <a href=\"/blog/software.html\">software</a>"
           "    | <a href=\"/blog/archive.html\">archive</a>"
           "    | <a href=\"/blog/rss.xml\">rss</a>"
           "  </div>"
           "</div>")))

  ;; Customize the HTML output
  (setq org-html-validation-link nil
        org-html-head-include-scripts nil
        org-html-head-include-default-style nil
        org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

  (setq org-publish-project-alist
        '(("orgfiles"
           :base-directory "~/org/"
           :base-extension "org"
           :publishing-directory "~/org/html"
           :publishing-function org-html-publish-to-html
           :headline-levels 3
           :section-numbers t
           :with-toc t
           :html-preamble t)

          ("images"
           :base-directory "~/org/images/"
           :base-extension "jpg\\|gif\\|png"
           :publishing-directory "~/org/html/images/"
           :publishing-function org-publish-attachment)

          ("other"
           :base-directory "~/org/other/"
           :base-extension "css\\|el"
           :publishing-directory "~/org/html/other/"
           :publishing-function org-publish-attachment)
          ("eightbitraptor" :components ("orgfiles" "images" "other"))))

#+end_src

** Audio

*** MPD client

Here we configure the built-in mpc-mode to connect to a running Mopidy server on
my home network desktop machine "senjougahara".

This relies on the following things:

- Mopidy is running with the MPD plugin on a host, using the default Mopidy port
- There is some way of mapping the hostname "senjougahara" to an IP. My network
  is small so I just use an entry in /etc/hosts for this.

MPC mode has a really weird UI. It _looks_ like it should behave like a "normal"
music player, it has selection windows for genre, artist, album etc. But there
doesn't seem to be any built in ways to manipulate the main playlist in MPD
beyond the standard mpc-add.

So there are a few helper functions in here that help to add groups of stuff to
the playlist, as well as remove things and clear down the playlist. All features
I use from ncmpcpp all the time.

I usually listen to Albums, so my workflow looks a bit like this:

- browse for the album I want
- press a to append it to the playlist
- press p to start playing (this toggles play/pause states)
- continue to add more albums as and when I feel like it.
- when I want a change, hit S to stop playing and clear the current playlist

  Soon I'll discover a simple way of selectively removing stuff from the
  playlist but I'm not quite there yet.

#+begin_src  emacs-lisp
  (use-package mpc
    :defer t
    :init
    ;; Declare functions to avoid warnings
    (declare-function mpc-select-toggle "mpc")
    (declare-function mpc-playlist-add "mpc")
    (declare-function mpc-tagbrowser-all-p "mpc")
    (defun ebr/mpc-unselect-all (&optional event)
      "Unselect all selected songs in the current mpc buffer."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (cond
           ((get-char-property (point) 'mpc-select)
            (let ((ols nil))
              (dolist (ol mpc-select)
                (if (and (<= (overlay-start ol) (point))
                         (> (overlay-end ol) (point)))
                    (delete-overlay ol)
                  (push ol ols)))
              (cl-assert (= (1+ (length ols)) (length mpc-select)))
              (setq mpc-select ols)))
           ((mpc-tagbrowser-all-p) nil)
           (t nil))
          (forward-line 1))))
    (defun ebr/mpc-add-selected ()
      "Append to playlist, then unmark the song."
      (interactive)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    (defun ebr/mpc-add-at-point-and-unmark ()
      "Mark, append to playlist, then unmark the song."
      (interactive)
      (mpc-select-toggle)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    :custom
    (mpc-host "senjougahara")
    (mpc-songs-format "%2{Disc--}%3{Track} %28{Title} %18{Album} %18{Artist}")
    (mpc-browser-tags '(Artist Album))
    (mpc-cover-image-re "[Ff]older.jpg")
    :bind (:map mpc-mode-map
                ("a" . ebr/mpc-add-at-point-and-unmark)
                ("A" . ebr/mpc-add-selected)
                ("c" . ebr/mpc-unselect-all)
                ("d" . mpc-playlist-delete)
                ("p" . mpc-toggle-play)
                ("P" . mpc-playlist)
                ("s" . mpc-select)
                ("S" . mpc-stop)))
#+end_src

** Emacs server

Finally we'll start a server attached to this GUI instance so that I
can use ~emacsclient~ in the terminal to open stuff in this instance.

#+begin_src emacs-lisp
  (use-package server
    :init (server-start))
#+end_src
