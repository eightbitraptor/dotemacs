#+TITLE: Main Emacs Configuration File
#+AUTHOR: Matthew Valentine-House
#+PROPERTY: header-args:emacs-lisp :tangle init.el :mkdirp yes

* Emacs config - eightbitraptor
:PROPERTIES:
:TOC: :include all
:END:


[[https://user-images.githubusercontent.com/31869/201213452-ad555d25-565d-4550-bffc-c64b00170de4.png]]

This is the latest incarnation of my emacs config. It's been built up, torn
down, refactored and rebuilt many times since I started using Emacs (the
earliest reference I can find is a really ugly screenshot of my work Mac circa
2011 - a long time before I knew remotely what I was doing :|).

:CONTENTS:
- [[#emacs-config---eightbitraptor][Emacs config - eightbitraptor]]
  - [[#introduction][Introduction]]
    - [[#setup-instructions][Setup Instructions]]
  - [[#general-editor-settings][General Editor Settings]]
    - [[#performance-and-startup-optimizations][Performance and Startup Optimizations]]
    - [[#tree-sitter-setup][Tree-sitter Setup]]
    - [[#setting-up-the-path][Setting up the PATH]]
    - [[#terminal-emulation][Terminal Emulation]]
    - [[#no-littering][No littering]]
    - [[#fish-mode][Fish mode]]
    - [[#dirvish][Dirvish]]
    - [[#icons][Icons]]
    - [[#organise-backup-files][Organise backup files]]
    - [[#theming-and-aesthetics][Theming and Aesthetics]]
    - [[#line-lengths][Line Lengths]]
    - [[#mouse-scrolling][Mouse Scrolling]]
    - [[#answer-prompt-questions-faster][Answer prompt questions faster]]
    - [[#ergonomics][Ergonomics]]
    - [[#default-indentation][Default Indentation]]
    - [[#default-selection-behaviour][Default Selection behaviour]]
    - [[#m-q-should-toggle-fill-paragraph][M-q should toggle Fill Paragraph]]
    - [[#configuring-the-gc][Configuring the GC]]
    - [[#undo-tree][Undo Tree.]]
    - [[#crux][Crux]]
    - [[#whitespace-butler][Whitespace Butler]]
  - [[#helper-functions][Helper Functions]]
    - [[#kill-other-buffers-and-focus-the-window][Kill other buffers and focus the window]]
    - [[#duplicate-lines][Duplicate lines]]
    - [[#quickly-change-frame-font-sizes][Quickly change frame font sizes]]
  - [[#keybindings][Keybindings]]
    - [[#custom-functions][Custom functions]]
    - [[#enhanced-navigation][Enhanced Navigation]]
    - [[#remap-m-x][Remap M-x]]
    - [[#resizing-windows][Resizing windows]]
    - [[#maximise-frames][Maximise frames]]
    - [[#delete-frames][Delete frames]]
    - [[#move-between-windows][Move between windows]]
    - [[#which-key-tooltips][Which key tooltips]]
  - [[#navigation-search--project-management][Navigation, Search & Project Management]]
    - [[#ripgrep][Ripgrep]]
    - [[#modern-completion-stack][Modern Completion Stack]]
      - [[#orderless][Orderless]]
      - [[#vertico][Vertico]]
      - [[#marginalia][Marginalia]]
      - [[#consult][Consult]]
      - [[#embark][Embark]]
    - [[#imenu-list][Imenu-list]]
    - [[#treemacs][Treemacs]]
    - [[#projectile][Projectile]]
    - [[#direnv][Direnv]]
    - [[#editorconfig][Editorconfig]]
  - [[#programming-utilities][Programming Utilities]]
    - [[#company-mode][Company Mode]]
    - [[#magit][Magit]]
    - [[#lsp][LSP]]
      - [[#consult-lsp-integration][Consult-LSP Integration]]
    - [[#dap-debug-adapter-protocol][DAP (Debug Adapter Protocol)]]
    - [[#ai-assistant-claude-code][AI Assistant (Claude Code)]]
  - [[#language-modes][Language Modes]]
    - [[#ruby][Ruby]]
    - [[#c][C]]
    - [[#rust][Rust]]
    - [[#r][R]]
    - [[#web-jshtmlcss][Web (js/html/css)]]
    - [[#zig][Zig]]
    - [[#markup-markdowntomlyaml][Markup (Markdown/toml/yaml)]]
  - [[#org-mode][Org Mode]]
    - [[#quick-notes-with-denote][Quick notes (with Denote)]]
    - [[#journal][Journal]]
    - [[#blogging][Blogging]]
  - [[#audio][Audio]]
    - [[#mpd-client][MPD client]]
  - [[#emacs-server][Emacs server]]
:END:


** Introduction

This configuration uses straight.el as a package manager and org babel to
document the configuration. Alongside this file there is also an early-init.el
which Emacs will run before setting up the GUI and before loading any other init
files.

The early-init in this repo does a couple of things:

1. Uses straight.el for packaging. That is:
   - install the latest version of straight.el if it's not already installed
   - disable the built in package.el
   - install use-package and configure it to use straight.el by
     default
2. Install the latest version of org-mode, with no config, just to be able to
   tangle this file.

I install the latest version of org-mode in the early init, to avoid any
compatability problems later on when using straight.el to properly configure org
and some dependencies that I like to use.

*** Setup Instructions

You should be able to clone this repo straight into ~/.emacs.d and start Emacs
and everything will be setup and configured on first start. Although note that
due to a lot of work being done in early-init.el (including loading this file)
the first startup will be very slow as all the packages are git cloned from
their various repositories, but also that _the UI will not be running_

This may make it look like it didn't work, but check in htop/Task
Manager/whatever and you should see the process active and doing stuff and
eventually Emacs will appear. This will only happen on first boot.

I appreciate the UX for this is shit. But it only happens once per machine, and
well; It doesn't really bother me enough to fix it.

** General Editor Settings

*** Performance and Startup Optimizations

Enable package quickstart for faster startup times. This pre-computes package
autoloads and saves them to a file that loads quickly.

#+begin_src emacs-lisp
  ;; Enable package quickstart (must be near the beginning)
  (setq package-quickstart t)

  ;; Ensure straight.el packages can be found
  (eval-when-compile
    (add-to-list 'load-path (expand-file-name "straight/build/" user-emacs-directory)))
#+end_src

*** Tree-sitter Setup

Enable Tree-sitter selectively for C/C++ and Rust where it provides significant benefits
for parsing complex syntax. Ruby uses enh-ruby-mode instead for better indent control
and mature tooling support.

#+begin_src emacs-lisp
  ;; Manual Tree-sitter configuration for better performance and control
  (when (treesit-available-p)
    ;; Define grammar sources for languages where Tree-sitter excels
    (setq treesit-language-source-alist
          '((c "https://github.com/tree-sitter/tree-sitter-c")
            (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
            (rust "https://github.com/tree-sitter/tree-sitter-rust")))

    ;; Use Tree-sitter modes for C/C++ and Rust only
    (setq major-mode-remap-alist
          '((c-mode . c-ts-mode)
            (c++-mode . c++-ts-mode)
            (rust-mode . rust-ts-mode)))

    ;; Note: Run M-x treesit-install-language-grammar for each language
    ;; on first use to compile the grammar libraries
    )
#+end_src

*** Setting up the PATH

I like to make sure that Emacs is using the same PATH and Ruby paths as my shell
for consistency. This is important on macOS where processes are started with a
different environment.

#+begin_src emacs-lisp
  ;; Cache for exec-path-from-shell to avoid repeated initialization
  (defvar mvh/exec-path-initialized nil
    "Whether exec-path-from-shell has been initialized.")

  (use-package exec-path-from-shell
    :if (memq system-type '(darwin gnu/linux))
    :defer t  ; Don't load immediately
    :config
    (setq exec-path-from-shell-variables '("PATH"
                                          "MANPATH"
                                          "GEM_HOME"
                                          "GEM_PATH"
                                          "RUBY_ROOT"
                                          "RUBY_ENGINE"
                                          "RUBY_VERSION"))
    (setq exec-path-from-shell-check-startup-files nil)
    (setq exec-path-from-shell-arguments '("-l"))  ; Use login shell for proper environment
    :commands (exec-path-from-shell-initialize))

  ;; Initialize exec-path lazily when needed for Ruby/programming modes
  (defun mvh/ensure-exec-path ()
    "Initialize exec-path from shell if not already done."
    (unless mvh/exec-path-initialized
      (require 'exec-path-from-shell nil t)
      (when (fboundp 'exec-path-from-shell-initialize)
        (exec-path-from-shell-initialize)
        (setq mvh/exec-path-initialized t))))

  ;; Hook into modes that need proper PATH
  (add-hook 'prog-mode-hook #'mvh/ensure-exec-path)

  (setq frame-resize-pixelwise t)
#+end_src

*** Terminal Emulation

Vterm provides a fully-featured terminal emulator inside Emacs, which is required
for packages like claude-code-ide that need to run interactive terminal sessions.

#+begin_src emacs-lisp
  (use-package vterm
    :defer t
    :config
    ;; Set shell to use
    (setq vterm-shell (or (getenv "SHELL") "/bin/bash"))
    ;; Kill buffer when process exits
    (setq vterm-kill-buffer-on-exit t)
    ;; Increase scrollback
    (setq vterm-max-scrollback 10000))
#+end_src

*** No littering

No littering makes etc and var directories inside .emacs.d and organises all the
files that Emacs and other packages would otherwise just dump directly into
.emacs.d

#+begin_src emacs-lisp
  (use-package no-littering)
#+end_src


*** Fish mode

I use the [[https://fishshell.com/][Fish shell]]. So I install the major mode for editing config
files.

#+begin_src emacs-lisp
  (use-package fish-mode)
#+end_src

*** Dirvish

Is a more fully featured dired mode. Let's try it out for a bit

#+begin_src emacs-lisp
  (use-package dirvish
    :init (dirvish-override-dired-mode))
#+end_src

*** Icons

Modern icon system using nerd-icons for completion, dired, and file trees.

#+begin_src emacs-lisp
  (use-package nerd-icons-completion
    :hook (marginalia-mode . nerd-icons-completion-mode)
    :init
    ;; Enable caching for better performance
    (setq nerd-icons-completion-cache t)
    :config

    ;; Add icon support for imenu items with caching
    (defvar nerd-icons-imenu-icon-cache nil
      "Cached icon string for imenu candidates.")

    (cl-defmethod nerd-icons-completion-get-icon (cand (_cat (eql imenu)))
      "Return cached icon for imenu candidates."
      (or nerd-icons-imenu-icon-cache
          (setq nerd-icons-imenu-icon-cache
                (concat (nerd-icons-codicon "nf-cod-symbol_method"
                                            :face 'font-lock-function-name-face
                                            :height (or nerd-icons-completion-icon-size 1.0))
                        " ")))))

  (use-package nerd-icons-dired
    :hook (dired-mode . nerd-icons-dired-mode)
    :config
    ;; Enable caching for better performance
    (setq nerd-icons-dired-cache t))
#+end_src

*** Organise backup files

This block turns off auto save, turns off automatic backups, and sets a backup
directory for any manually created backups to be inside the
~user-emacs-directory~ which is ~.emacs.d~. This avoids littering projects with
lots of ~~~ files, that aren't often gitignored.

#+begin_src emacs-lisp
  (let ((backup-dir (expand-file-name "backup/" user-emacs-directory))
        (autosave-dir (expand-file-name "autosave/" user-emacs-directory)))
    (when (not (file-directory-p autosave-dir))
      (make-directory autosave-dir))
    (when (not (file-directory-p backup-dir))
      (make-directory backup-dir))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir)))
    (setq backup-by-copying t))
#+end_src

*** Theming and Aesthetics

First install solaire-mode, this changes the background colour of "unreal"
buffers - ie. buffers that are not backed by a file. In general use this has the
effect of making files being edited immediately and obviously distinct from
other types of buffers, like dired, treemacs, magit, or the find-file buffer.

This feature is one of the things I really enjoyed, visually, about VSCode

#+begin_src emacs-lisp
  (use-package solaire-mode
    :hook (after-init . solaire-global-mode))
#+end_src

Now set up a theme. We need to choose a theme here that explicitly supports
solaire-mode.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-moonlight :no-confirm))
#+end_src

Then nyan cat as a progress bar in my modeline

#+begin_src emacs-lisp
  (use-package nyan-mode
    :init (nyan-mode))
#+end_src

Silence the audible bell, and make the visual bell quite a bit more subtle -
just flash the text on the modeline white briefly, rather than flashing the
whole window.

#+begin_src emacs-lisp
  (setq ring-bell-function
      (lambda ()
        (let ((orig-fg (face-foreground 'mode-line)))
          (set-face-foreground 'mode-line "#FFFFFF")
          (run-with-idle-timer 0.1 nil
                               (lambda (fg) (set-face-foreground 'mode-line fg))
                               orig-fg))))
#+end_src

I like the cursor to be an I-beam. The toolbars and scrollbars are disabled
in early-init.el for faster startup and a clean looking frame.

#+begin_src emacs-lisp
  (setq-default cursor-type 'bar)
  (when (display-graphic-p)
    (toggle-scroll-bar -1)
    (tool-bar-mode 0))
  (menu-bar-mode 0)
#+end_src

Don't display text in the startup buffer or the scratch buffer by default

#+begin_src emacs-lisp
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
#+end_src

Increase the line spacing a little from the default and turn on line numbers
globally.

#+begin_src emacs-lisp
  (setq-default line-spacing 5)
  ;; Enable line numbers only in programming modes for better performance
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

Now we'll configure the default fonts. We have to do this per OS because
everything renders fonts differently and at different sizes.

#+begin_src emacs-lisp
  (cond ((eq system-type 'gnu/linux)
         (set-face-attribute 'default nil :font "JetBrains Mono 14"))
        ((eq system-type 'darwin)
         (setq mac-frame-tabbing nil)
         (set-face-attribute 'default nil :font "Jetbrains Mono 16"))
        ((eq system-type 'windows-nt)
         (set-face-attribute 'default nil :font "Consolas 16")))
#+end_src

I spend time manually resizing my Emacs frame ususally when it starts, I usually
want it to just take up roughly 70% of the screen, and be centered, so let's
make it do that. I used this code almost verbatim from here, but had to change
the width calculation to consider multiple monitors used horizontally. This will
always open the initial frame on the Primary monitor.

https://www.reddit.com/r/emacs/comments/9c0a4d/tip_setting_initial_frame_size_and_position/

#+begin_src emacs-lisp
  ;; Set initial frame size and position

  (defun mvh/set-initial-frame ()
    (when (display-graphic-p)
      (let* ((base-factor 0.85)
             (primary-monitor-actual-width
              (nth 3 (assoc 'geometry (car (display-monitor-attributes-list)))))
           (a-width (* primary-monitor-actual-width base-factor))
           (a-height (* (display-pixel-height) base-factor))
           (a-left (truncate (/ (- primary-monitor-actual-width a-width) 2)))
           (a-top (truncate (/ (- (display-pixel-height) a-height) 2))))
        (set-frame-position (selected-frame) a-left a-top)
        (set-frame-size (selected-frame) (truncate a-width)  (truncate a-height) t))))
  (mvh/set-initial-frame)
#+end_src


*** Line Lengths

Break all long lines automatically at ~fill-column~ so I don't have to press
~M-q~ all the time. And then set ~fill-column~ to 80 chars, because 70 is a bit short.

Because I enable ~auto-fill-mode~ I also provide a convenience
function, bound to ~C-c u~ to unfill any paragrahs that get broken
when I don't want them to be.

#+begin_src emacs-lisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

  (defun unfill-paragraph ()
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))
  (global-set-key (kbd "C-u") 'unfill-paragraph)
#+end_src

Also enable a vertical ruler at 80 columns using
~display-fill-column-indicator-mode~ everywhere.

#+begin_src emacs-lisp
  (global-display-fill-column-indicator-mode)
#+end_src

*** Mouse Scrolling

This controls how many lines the mouse wheel scrolls by.

#+begin_src emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
#+end_src

#+begin_src emacs-lisp
  ;; Disabled beacon-mode for better performance
  ;; (use-package beacon
  ;;   :config (beacon-mode 1))
#+end_src

*** Answer prompt questions faster

Use y/n in prompts instead of having to explicitly type yes or no

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Ergonomics

I always used to smash these keys accidentally and they'd do random
stuff. I was bad at typing!

I don't think I've had this problem since I changed to using split
ergo keyboards, so I'm not sure whether it's still relevant or
not. At some point I'll get around to testing that...

#+begin_src emacs-lisp
  (when window-system
    ((lambda ()
       (global-unset-key "\C-z")
       (global-unset-key "\C-x\C-z"))))
#+end_src

Also enable Auto-revert mode globally. I do a lot of stuff on the command line
and in other tools, it's nice to not have to get hit with the prompt when I
switch back to Emacs and try to edit something.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

*** Default Indentation

Default to 4 spaces as an indent everywhere. Obviously other modes are
going to override this as necessary, but I like a 4 space indent
generally.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default c-basic-offset 4)
#+end_src

*** Default Selection behaviour

And turn on ~delete-selection-mode~. This makes emacs visual selection behave
much more like "modern" editors. ie. when you select stuff and start typing your
text will _replace_ the selected text, and you can highlight text and then hit
backspace to delete it.

Without this minor mode enabled Emacs will start inserting text wherever the
point is located (often at the end of the selection), and not actually remove
the seletion.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

*** M-q should toggle Fill Paragraph

#+begin_src emacs-lisp
  (use-package unfill
    :bind ([remap fill-paragraph] . unfill-toggle))
#+end_src

*** Configuring the GC

GC settings are now optimized in early-init.el for better startup performance.
These values are restored after init to reasonable runtime values.

#+begin_src emacs-lisp
  ;; GC settings moved to early-init.el for better startup performance
  ;; Runtime values are set in emacs-startup-hook
#+end_src

*** Undo Tree.

This package is magical, it lets you see the entire edit history of
your file as a tree instead of a linear series of changes. It also
provides a way of visualising the tree, so you can get back basically
any change you make while editing a file.

#+begin_src emacs-lisp
    (use-package undo-tree
      :init (setq undo-tree-auto-save-history nil
                  undo-tree-history-directory-alist '("~/.emacs.d/autosave/"))

      :config (global-undo-tree-mode))
#+end_src

*** Crux

Crux really is a collection of really useful extensions! The ones I
like are:

- ~crux-move-beginning-of-line~ bounces between the first non
  whitespace char in the line and the actual beginning of the line
- ~crux-smart-open-line-above~ Inserts a new line above the point and
  indents it according to the context. Basically the same as ~O~ in
  Vim.
- ~crux-smart-kill-line~ kills from the point to the end of the line,
  then when pressed again, kills the rest of the line. Just means I
  can usually hit ~C-k~ twice instead of ~C-a C-k~ which is quicker.

#+begin_src emacs-lisp
  (use-package crux
    :bind (("C-a" . crux-move-beginning-of-line)
           ("C-o" . crux-smart-open-line-above)
           ("C-k" . crux-smart-kill-line)))

#+end_src

*** Whitespace Butler

Makes sure I don't accidentally commit loads of bad whitespace.

#+begin_src emacs-lisp
  (use-package ws-butler
    :hook (prog-mode . ws-butler-mode)  ; Only in programming modes
    :config
    (setq ws-butler-keep-whitespace-before-point nil))
#+end_src

** Helper Functions

A few things that I've found useful over the years. They should
already be pretty well documented - just checkout the function
documentation.

*** Kill other buffers and focus the window

#+begin_src emacs-lisp
  (defun kill-other-buffers ()
    "Make the current buffer the only focus, and kill other buffers
  that are associated with files."
    (interactive)
    (delete-other-windows)
    (mapc 'kill-buffer
          (delq (current-buffer)
                (remove nil (mapcar #'(lambda (b) (when (buffer-file-name b) b))
                                    (buffer-list))))))

#+end_src

*** Duplicate lines

#+begin_src emacs-lisp
  (defun duplicate-line (arg)
    "Duplicate current line, leaving point in lower line."
    (interactive "*p")
    ;; save the point for undo
    (setq buffer-undo-list (cons (point) buffer-undo-list))
    ;; local variables for start and end of line
    (let ((bol (save-excursion (beginning-of-line) (point)))
          eol)
      (save-excursion
        ;; don't use forward-line for this, because you would have
        ;; to check whether you are at the end of the buffer
        (end-of-line)
        (setq eol (point))

        ;; store the line and disable the recording of undo information
        (let ((line (buffer-substring bol eol))
              (buffer-undo-list t)
              (count arg))
          ;; insert the line arg times
          (while (> count 0)
            (newline)         ;; because there is no newline in 'line'
            (insert line)
            (setq count (1- count)))
          )

        ;; create the undo information
        (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
      ) ; end-of-let

    ;; put the point in the lowest line and return
    (forward-line arg))
#+end_src

*** Quickly change frame font sizes

Useful when sharing my screen on a vidoe call so the font can be
legible on the recording.

#+begin_src emacs-lisp
  (defun my-alter-frame-font-size (fn)
    (when (display-graphic-p)
      (let* ((current-font-name (frame-parameter nil 'font))
             (decomposed-font-name (x-decompose-font-name current-font-name))
             (font-size (string-to-number (aref decomposed-font-name 5))))
        (aset decomposed-font-name 5 (number-to-string (funcall fn font-size)))
        (set-frame-font (x-compose-font-name decomposed-font-name)))))

  (defun my-inc-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1+))

  (defun my-dec-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1-))
#+end_src

** Keybindings

*** Custom functions

First map some of the aformentioned custom functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-d") 'duplicate-line)
  (global-set-key (kbd "C-+") 'my-inc-frame-font-size)
  (global-set-key (kbd "C-=") 'my-inc-frame-font-size)
  (global-set-key (kbd "C--") 'my-dec-frame-font-size)
#+end_src

*** Enhanced Navigation

Add standard Emacs navigation bindings for better call stack navigation.
These work alongside the existing M-t/M-T fuzzy search setup.

#+begin_src emacs-lisp
  ;; Standard xref navigation bindings
  (global-set-key (kbd "M-.") 'xref-find-definitions)     ; Go to definition
  (global-set-key (kbd "M-,") 'xref-go-back)             ; Go back in stack
  (global-set-key (kbd "M-?") 'xref-find-references)     ; Find references
  (global-set-key (kbd "C-M-.") 'xref-find-apropos)      ; Find symbols matching pattern

  ;; Additional navigation helpers
  (global-set-key (kbd "C-M-,") 'xref-go-forward)        ; Go forward in stack (if available)
#+end_src

*** Remap M-x

This is something I learned from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's excellent blog post
about effective Emacs]] - Use a key combo for ~M-x~ that doesn't
involve the ~Alt~ key as it's non standard across environments and
requires some weird hand scrunching to type properly.

I also like ~C-x C-m~ as it has as kind of tempo to it (command
sequences having tempo is a really nice idea I learned about in [[https://www.masteringemacs.org/][Mickey
Peterson's Mastering Emacs book]] back in the day.

#+begin_src emacs-lisp
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
#+end_src

*** Resizing windows

Some keybindings for resizing Windows. I can't remember when I last
used these but you know I'd need them if I ever got rid of them so
here they are.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<left>")  'shrink-window-horizontally)
  (global-set-key (kbd "s-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "s-<up>")    'enlarge-window)
  (global-set-key (kbd "s-<down>")  'shrink-window)
#+end_src

*** Maximise frames

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)
#+end_src

*** Delete frames

With Emacs server running

#+begin_src emacs-lisp
  (global-set-key (kbd "M-∑") 'delete-frame)
#+end_src

*** Move between windows

Enable windmove keybingings. This slightly arcanely named setting
means you can move between windows with ~shift-u/d/l/r~ rather than
cycling through with ~C-x o~ or the mouse.

#+begin_src emacs-lisp
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
#+end_src

*** Which key tooltips

This package pops up a buffer containing all possible key combinations
if you hit the start of a chord. I hope to one day not need this, but
it's stupidly useful when using stuff I don't normally use everyday.

I've set the delay to be quite long at 3s, just to make sure it
doesn't get in my way when I'm doing normal things.

The configuration below also adds descriptive labels for various prefix keys
and custom commands to make them more discoverable. This includes grouping
related commands under descriptive prefixes and providing clear descriptions
for custom functions that might not be obvious from their names.

#+begin_src emacs-lisp
  (use-package which-key
    :defer 1  ; Load 1 second after startup
    :config
    (which-key-mode)
    (setq which-key-idle-delay 3)

    ;; Add descriptions for custom commands
    (which-key-add-key-based-replacements
      "C-d" "duplicate line"
      "C-u" "unfill paragraph"
      "C-+" "increase font size"
      "C-=" "increase font size"
      "C--" "decrease font size"
      "M-t" "find symbol in buffer"
      "M-T" "find symbol in project"
      "M-o" "find file in project"
      "C-S-g" "grep project"
      "M-∑" "delete frame")

    ;; Group C-c commands
    (which-key-add-key-based-replacements
      "C-c h" "consult history"
      "C-c m" "consult mode command"
      "C-c k" "consult kmacro"
      "C-c s" "magit status"
      "C-c C-t" "toggle imenu sidebar"
      "C-c p" "projectile"
      "C-c l" "lsp"
      "C-c j" "journal")

    ;; Group window management commands
    (which-key-add-key-based-replacements
      "s-<left>" "shrink window width"
      "s-<right>" "enlarge window width"
      "s-<up>" "enlarge window height"
      "s-<down>" "shrink window height"
      "s-<return>" "toggle fullscreen"
      "s-'" "go back (xref)")

    ;; Navigation and search groups
    (which-key-add-key-based-replacements
      "M-g" "goto"
      "M-s" "search"
      "C-x r" "registers/rectangles")

    ;; Embark actions
    (which-key-add-key-based-replacements
      "C-." "embark act"
      "C-;" "embark dwim"
      "C-h B" "embark bindings")

    ;; Execution commands
    (which-key-add-key-based-replacements
      "C-x C-m" "execute command (M-x)"
      "C-c C-m" "execute command (M-x)"
      "C-x C-n" "create note (denote)"))

#+end_src

** Navigation, Search & Project Management

*** Ripgrep

for fast project searches, relies on the ~rg~ binary being somewhere
on your path.

#+begin_src emacs-lisp
  (use-package ripgrep
    :defer t)
#+end_src

*** Modern Completion Stack

Modern completion framework using vertico, orderless, consult, marginalia, and embark.
This replaces the ivy/counsel ecosystem with more performant and flexible alternatives.

**** Orderless

Orderless provides flexible completion matching. Unlike ivy's built-in matching,
orderless allows space-separated components that can match in any order, making
it much more powerful for finding completions.

#+begin_src emacs-lisp
  (use-package orderless
    :demand t
    :config
    ;; Configure completion styles for optimal performance
    (setq completion-styles '(orderless flex basic partial-completion)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion)))))

    ;; Configure orderless matching styles - optimized for performance
    (setq orderless-matching-styles '(orderless-literal orderless-regexp orderless-flex))

    ;; Ensure completion updates as you type
    (setq orderless-component-separator "[ &]"))  ; Space or & as separators
#+end_src

**** Vertico

Vertico provides a clean, fast completion UI that integrates perfectly with
Emacs' built-in completion system. It's much lighter than ivy while providing
better performance and integration.

#+begin_src emacs-lisp
  (use-package vertico
    :demand t
    :config
    (vertico-mode)

    ;; Performance and UX optimizations
    (setq vertico-count (if (display-graphic-p) 15 8)  ; Fewer lines in terminal
          vertico-resize nil        ; Keep minibuffer height fixed
          vertico-cycle t)          ; Cycle through completions

    ;; Enable recursive minibuffers for complex operations
    (setq enable-recursive-minibuffers t)

    ;; Control minibuffer window height
    (setq max-mini-window-height 0.3)  ; Max 30% of frame height
    (setq resize-mini-windows t))       ; Allow resizing but respect max
#+end_src

**** Marginalia

Marginalia adds rich annotations to completion candidates, replacing ivy-rich
with a more flexible and performant system that works with any completion UI.

#+begin_src emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (marginalia-mode)

    ;; Bind M-A to cycle annotation levels in minibuffer
    (define-key minibuffer-local-map (kbd "M-A") 'marginalia-cycle)

    ;; Enable nerd-icons integration
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src


**** Consult

Consult provides enhanced versions of many built-in commands with live previews,
async operations, and better integration. It replaces counsel and swiper.

#+begin_src emacs-lisp
  (use-package consult
    :demand t
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)
           ("C-x b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x r b" . consult-bookmark)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)
           ("M-g g" . consult-goto-line)
           ("M-g M-g" . consult-goto-line)
           ("M-g o" . consult-outline)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; M-t bound separately for flattened imenu
           )
    :hook (completion-list-mode . consult-preview-at-point-mode)
    :config
    ;; Configure preview and async operations
    (setq consult-preview-key "M-."
          consult-narrow-key "<"
          consult-project-function (lambda (_)
                                     (when (fboundp 'projectile-project-root)
                                       (projectile-project-root))))

    ;; Configure async operations for performance
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-recent-file
     consult--source-project-recent-file
     :preview-key "M-.")

    ;; Configure consult-imenu to be completely flat - no grouping or toplevel categories
    (setq consult-imenu-config
          '((t :toplevel nil :types nil)))  ; No toplevel grouping, no type categories

    ;; Bind M-t to regular consult-imenu (now configured to be flat)
    (global-set-key (kbd "M-t") 'consult-imenu))
#+end_src

**** Embark

Embark provides context-sensitive actions on completion candidates, offering
functionality not available in the ivy ecosystem. You can act on candidates
or export them to dedicated buffers.

#+begin_src emacs-lisp
  (use-package embark
    :defer t
    :bind (("C-." . embark-act)
           ("C-;" . embark-dwim)
           ("C-h B" . embark-bindings))
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :defer t
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Imenu-list

This is the most lightweight equivalent of Vim's [[https://github.com/preservim/tagbar][Tagbar plugin]] that I
could find. It uses ~imenu-mode~ to breakdown a source file and show
you a list of Classes, structures functions and whatnot in a vertical
bar on the right of the frame.

Fair warning though. It seems to crap itself in ~org-mode~.

#+begin_src emacs-lisp
  (use-package imenu-list
    :bind ("C-c C-t" . imenu-list-smart-toggle))
#+end_src

*** Treemacs

Treemacs provides an IDE-style file tree sidebar with git integration, icons,
and mouse support. It works well with our existing projectile and LSP setup.

#+begin_src emacs-lisp
  (use-package treemacs
    :defer t
    :init
    ;; Add and expand projects automatically when visiting files
    (setq treemacs-project-follow-mode t
          treemacs-follow-mode t)
    :config
    ;; Basic settings - only what we need to change from defaults
    (setq treemacs-width 35
          treemacs-click-mouse-1 'single-click)  ; Single click to expand/collapse

    ;; Enable modes for auto-behavior
    (treemacs-follow-mode t)              ; Follow current buffer's file
    (treemacs-project-follow-mode t)      ; Auto-add projects when opening files
    (treemacs-filewatch-mode t)           ; Auto-refresh on file changes
    (treemacs-fringe-indicator-mode t)    ; Show position indicator

    ;; Enable git colors if available
    (when (executable-find "git")
      (treemacs-git-mode 'deferred))

    ;; Use nerd-icons since we already have it
    (treemacs-resize-icons 18)

    :bind
    (("C-x t t" . treemacs)
     ("C-x t 0" . treemacs-select-window)))

  ;; Integration with projectile for project management
  (use-package treemacs-projectile
    :after (treemacs projectile))

  ;; Integration with magit for better git status display
  (use-package treemacs-magit
    :after (treemacs magit))

  ;; Use nerd-icons instead of all-the-icons for consistency with your setup
  (use-package treemacs-nerd-icons
    :after treemacs
    :config (treemacs-load-theme "nerd-icons"))
#+end_src

*** Projectile

#+begin_src emacs-lisp
  ;; Projectile spins trying to calculate what to write in the modeline when using TRAMP.
  ;; forcing a static modeline causes tramp mode to get fast again
  (use-package projectile
    :config (setq projectile-dynamic-mode-line nil)
    (projectile-mode +1)
    :bind-keymap ("C-c p" . projectile-command-map)
    :bind (("M-o" . projectile-find-file)
           ("C-S-g" . projectile-grep))
    :init (setq projectile-completion-system 'default))

  (use-package ag
    :defer t)

  (use-package projectile-rails
    :defer t
    :config (projectile-rails-global-mode t))
  (use-package projectile-ripgrep
    :defer t)
#+end_src

*** Direnv

Direnv is heckin useful, I use it everywhere! You need the binary
installed and set up in your shell, but then you can create a ~.envrc~
file in a directory, export shell variables in it, and they're only
applied when you're in that directory.

I use it mainly for setting cflags on various projects.

#+begin_src emacs-lisp
  (use-package direnv
    :if (executable-find "direnv")
    :init (direnv-mode))
#+end_src

*** Editorconfig

Support the ubiquitous ~.editorconfig~ files that keep cropping up all
over the place.

Personally I'm a little uncomfortable about other people having
control over my editor settings, but there's no doubt they are
useful. And we use them at work, so I guess I'll just deal with it.

#+begin_src emacs-lisp
  (use-package editorconfig
    :init (editorconfig-mode 1))
#+end_src

** Programming Utilities

*** Company Mode

Company handles completion lists and auto-complete stuff. I experimented with
Corfu and cape but ultimately stuck with company because I want completion that
narrows down as I type rather than a static list that corfu provides.

Company has been around forever and just works. It's pretty solid with LSP,
handles huge completion lists, and pretty much every programming mode supports
it out of the box.

#+begin_src emacs-lisp
      (use-package company
        :hook (prog-mode . company-mode)  ; Only in programming modes
        :config
        ;; Core performance and behavior settings
        (setq company-idle-delay 0.3              ; Small delay for better typing experience
              company-minimum-prefix-length 1     ; Show completions after just 1 character
              company-tooltip-limit 10            ; Limit shown candidates for performance
              company-tooltip-align-annotations t ; Align annotations on the right
              company-require-match nil           ; Allow free typing
              company-dabbrev-downcase nil        ; Preserve case in dabbrev completions
              company-dabbrev-ignore-case nil     ; Case-sensitive dabbrev
              company-show-quick-access t         ; Show quick-access numbers
              company-selection-wrap-around t)    ; Wrap around when cycling

        ;; Enable dynamic filtering - the key feature you want
        (setq company-backends
              '((company-capf              ; Completion-at-point (includes LSP)
                 company-dabbrev-code      ; Dynamic abbreviations from code
                 company-keywords          ; Programming language keywords
                 company-files             ; File path completion
                 company-dabbrev)))        ; Dynamic abbreviations from all buffers

        ;; Ensure completions update as you type
        (setq company-abort-on-unique-match nil   ; Don't abort on unique match
              company-continue-commands t)         ; Continue showing popup while typing

        ;; Key bindings for navigation
        (define-key company-active-map (kbd "TAB") 'company-complete-selection)
        (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
        (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
        (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
        (define-key company-active-map (kbd "C-n") 'company-select-next)
        (define-key company-active-map (kbd "C-p") 'company-select-previous)
        (define-key company-active-map (kbd "M-n") 'company-select-next-or-abort)
        (define-key company-active-map (kbd "M-p") 'company-select-previous-or-abort)

        ;; Improve performance with large candidate lists
        (setq company-tooltip-idle-delay 0.3
              company-async-timeout 5)

        ;; Enable Company in specific modes where it might be disabled
        (dolist (hook '(eshell-mode-hook
                        shell-mode-hook))
          (add-hook hook 'company-mode)))

      ;; Use Company's built-in VSCode-style icons
      (with-eval-after-load 'company
        ;; Enable VSCode-style text icons that work everywhere
        (setq company-format-margin-function #'company-vscode-dark-icons-margin))

      ;; Use Dabbrev with Company
      (use-package dabbrev
        ;; Swap M-/ and C-M-/
        :bind (("M-/" . dabbrev-completion)
               ("C-M-/" . dabbrev-expand))
        :config
        (setq dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))

      ;; Company terminal support for non-graphical Emacs
      (when (not (display-graphic-p))
        (with-eval-after-load 'company
          ;; Disable company-box in terminal
          (setq company-box-enable nil)))

      ;; LSP integration with Company
      ;; Company automatically uses company-capf which LSP configures
      (with-eval-after-load 'lsp-mode
        ;; Ensure Company is used for completions
        (setq lsp-completion-provider :capf)

        ;; Configure LSP to work well with Company's dynamic filtering
        (setq lsp-completion-show-detail t
              lsp-completion-show-kind t
              lsp-completion-enable-additional-text-edit t
              lsp-enable-snippet t)

        ;; Make sure Company respects LSP's sorting
        (add-hook 'lsp-managed-mode-hook
                  (lambda ()
                    (setq-local company-transformers nil))))

#+end_src

*** Magit

Magit mode is, imo, Emacs killer feature. Or at least on of the top
ones. It's an amazing way of interacting with Git.

No config to really note - I've set the magit status window to take up
the whole frame, because when I context switch into Git mode I like to
focus fully on it.

I've also enabled ~vc-follow-symlinks~ which helps out if you ever try
and edit a symlink pointing to a file under source control, by
following the link and opening the original file in Emacs.

#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
  ;; Declare function to avoid warnings
  (declare-function magit-display-buffer-fullframe-status-v1 "magit")

  (use-package magit
    :defer t
    :init (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (setq magit-push-current-set-remote-if-missing nil)
    :bind ("C-c s" . magit-status))
#+end_src

*** LSP

LSP configuration provides intelligent IDE-like features across multiple languages
(C, Ruby, and Rust). The configuration optimizes for performance with reasonable
delays, enables intelligent completion via completion-at-point-functions, and
includes signature help for function parameters.

For Ruby development, the configuration includes:
- Automatic ruby-lsp installation when not found
- Support for both system Ruby (with --user-install) and chruby-managed Rubies
- Automatic PATH updates to find gems installed for the current Ruby version
- Sorbet LSP support with automatic installation for Sorbet projects
- Smart bundler detection - uses `bundle exec` when ruby-lsp is in the Gemfile
- A wrapper script approach for ruby-lsp that ensures chruby is sourced before
  execution, solving PATH issues when LSP starts before chruby initialization

Navigation works on multiple levels: ~M-t~ for buffer-scope symbol search via imenu,
~M-T~ for project-wide workspace symbols, and standard Emacs bindings (~M-.~ for
go-to-definition, ~M-,~ for go-back) for call stack navigation. This creates a
comprehensive code navigation system that scales from buffer to project scope.

#+begin_src emacs-lisp
    (use-package flycheck)

    (use-package lsp-mode
      :commands (lsp lsp-deferred)
      :init
      (setq lsp-keymap-prefix "C-c l")
      :config
      (setq lsp-idle-delay 0.5  ; Balance between responsiveness and performance
                    lsp-headerline-breadcrumb-enable nil
                    lsp-enable-on-type-formatting nil
                    lsp-enable-indentation nil
                    lsp-solargraph-formatting nil
                    lsp-eldoc-enable-hover nil
                    lsp-enable-snippets nil
                    ;; Optimize completion settings
                    lsp-completion-provider :capf
                    lsp-completion-enable t
                    lsp-completion-show-detail t
                    lsp-completion-show-kind t
                    ;; Enable signature help for function parameters
                    lsp-signature-auto-activate t
                    lsp-signature-render-documentation nil  ; Keep signatures concise
                    ;; Language server specific settings
                    lsp-rust-analyzer-cargo-watch-command "clippy"
                    lsp-rust-analyzer-server-display-inlay-hints t
                    lsp-enabled-clients '(clangd
                                          ruby-lsp-ls
                                          rust-analyzer)
                    ;; Explicitly disable other Ruby language servers to suppress warnings
                    lsp-disabled-clients '(steep-ls
                                           solargraph
                                           sorbet-ls
                                           ruby-ls
                                           semgrep-ls
                                           ruby-syntax-tree-ls
                                           rubocop-ls
                                           typeprof-ls)
                    ;; Configure ruby-lsp to use the correct command
                    lsp-ruby-lsp-server-command '("ruby-lsp")
                    lsp-clients-clangd-args '("--header-insertion=never"
                                              "--enable-config"
                                              "--all-scopes-completion"
                                              "--background-index"))
      :hook ((c-mode . lsp-deferred)
             (c++-mode . lsp-deferred)
             (c-ts-mode . lsp-deferred)
             (c++-ts-mode . lsp-deferred)
             (ruby-mode . lsp-deferred)
             (enh-ruby-mode . lsp-deferred)
             (rustic-mode . lsp-deferred)
             (lsp-mode . lsp-enable-which-key-integration))
      :bind (("<mouse-4>" . lsp-find-definition)
             ("S-<down-mouse-1>" . lsp-find-definition)
             ("S-<down-mouse-2>" . lsp-find-references)
             ("<mouse-5>" . xref-go-back)
             ("<f12>" . lsp-find-references)
             ("s-'" . xref-go-back))
      :bind-keymap ("C-c l" . lsp-command-map))

  ;; Additional LSP helper functions (defined outside use-package for availability)
  (defun mvh/update-gem-path-for-chruby ()
    "Update PATH to include gem bin directories for the current Ruby.
This is necessary because chruby changes the Ruby executable but doesn't
automatically update Emacs' exec-path with the corresponding gem bin directories.
We add both the user gem directory (for gems installed with --user-install)
and the default gem directory (for regular gem installs)."
    (when (executable-find "ruby")
      (let* ((gem-info (shell-command-to-string "ruby -e 'puts Gem.user_dir; puts Gem.default_dir'"))
             (gem-lines (split-string gem-info "\n" t))
             (gem-user-dir (car gem-lines))
             (gem-default-dir (cadr gem-lines)))
        ;; Add user gem bin directory
        (when gem-user-dir
          (let ((user-bin (expand-file-name "bin" gem-user-dir)))
            (when (file-directory-p user-bin)
              (add-to-list 'exec-path user-bin)
              (setenv "PATH" (concat user-bin ":" (getenv "PATH"))))))
        ;; Add default gem bin directory
        (when gem-default-dir
          (let ((default-bin (expand-file-name "bin" gem-default-dir)))
            (when (file-directory-p default-bin)
              (add-to-list 'exec-path default-bin)
              (setenv "PATH" (concat default-bin ":" (getenv "PATH")))))))))

  ;; Manual command to install ruby-lsp if needed
  (defun mvh/install-ruby-lsp ()
    "Manually install ruby-lsp for the current Ruby version."
    (interactive)
    (message "Installing ruby-lsp...")
    (let* ((ruby-path (executable-find "ruby"))
           (use-user-install (string-prefix-p "/usr/bin" (or ruby-path "")))
           (install-cmd (if use-user-install
                           "gem install --user-install ruby-lsp"
                         "gem install ruby-lsp")))
      (if (zerop (call-process-shell-command install-cmd nil nil nil))
          (progn
            (mvh/update-gem-path-for-chruby)
            (message "ruby-lsp installed successfully"))
        (message "Failed to install ruby-lsp. Please install manually: %s" install-cmd))))

  ;; Configure ruby-lsp for bundler projects (simplified, no auto-install)
  (defun mvh/configure-ruby-lsp-for-project ()
    "Configure ruby-lsp to use bundler when appropriate."
    (when (fboundp 'lsp-mode)
      ;; Check if we're in a bundler project
      (let ((gemfile (locate-dominating-file default-directory "Gemfile")))
        (when gemfile
          ;; Check if ruby-lsp is in the Gemfile
          (let ((gemfile-path (expand-file-name "Gemfile" gemfile))
                (has-ruby-lsp nil))
            (when (file-exists-p gemfile-path)
              (with-temp-buffer
                (insert-file-contents gemfile-path)
                (setq has-ruby-lsp
                      (save-excursion
                        (goto-char (point-min))
                        (re-search-forward "ruby-lsp" nil t)))))
            ;; Set the buffer-local variable
            (setq-local lsp-ruby-lsp-use-bundler has-ruby-lsp))))))

  ;; Hook to configure ruby-lsp when entering ruby modes
  ;; Add with lower priority (positive depth) to run after chruby
  (add-hook 'ruby-mode-hook 'mvh/configure-ruby-lsp-for-project 90)
  (add-hook 'enh-ruby-mode-hook 'mvh/configure-ruby-lsp-for-project 90)

  ;; Configure lsp-mode settings for ruby-lsp (only after lsp-mode is loaded)
  (with-eval-after-load 'lsp-mode
    (lsp-register-custom-settings
     '(("ruby-lsp.bundleGemfile" nil t)
       ("ruby-lsp.formatter" "auto" t))))

  ;; Create a wrapper script for ruby-lsp that handles Ruby version detection
  (defun mvh/create-ruby-lsp-wrapper ()
    "Create a wrapper script for ruby-lsp that works with chruby."
    (let ((wrapper-path (expand-file-name "~/.emacs.d/bin/ruby-lsp-wrapper")))
      (make-directory (file-name-directory wrapper-path) t)
      (with-temp-file wrapper-path
        (insert "#!/usr/bin/env bash\n"
                "# Wrapper script for ruby-lsp to work with chruby\n"
                "\n"
                "# Source chruby if available\n"
                "if [ -f /opt/homebrew/share/chruby/chruby.sh ]; then\n"
                "  source /opt/homebrew/share/chruby/chruby.sh\n"
                "elif [ -f /usr/local/share/chruby/chruby.sh ]; then\n"
                "  source /usr/local/share/chruby/chruby.sh\n"
                "fi\n"
                "\n"
                "# Auto-switch Ruby version based on .ruby-version\n"
                "if [ -f /opt/homebrew/share/chruby/auto.sh ]; then\n"
                "  source /opt/homebrew/share/chruby/auto.sh\n"
                "elif [ -f /usr/local/share/chruby/auto.sh ]; then\n"
                "  source /usr/local/share/chruby/auto.sh\n"
                "fi\n"
                "\n"
                "# Execute ruby-lsp\n"
                "exec ruby-lsp \"$@\"\n"))
      (set-file-modes wrapper-path #o755)
      wrapper-path))

  ;; Create the wrapper script at startup and configure LSP to use it
  (defvar mvh/ruby-lsp-wrapper-path nil
    "Path to the ruby-lsp wrapper script.")

  (setq mvh/ruby-lsp-wrapper-path (mvh/create-ruby-lsp-wrapper))
  ;; Add the wrapper directory to exec-path
  (add-to-list 'exec-path (file-name-directory mvh/ruby-lsp-wrapper-path))

  ;; Override the ruby-lsp server command to use our wrapper
  (with-eval-after-load 'lsp-mode
    (when mvh/ruby-lsp-wrapper-path
      (setq lsp-ruby-lsp-server-command (list mvh/ruby-lsp-wrapper-path))))

  (use-package lsp-ui
    :config (setq lsp-ui-sideline-mode nil
                    lsp-ui-flycheck-live-reporting nil
                    lsp-ui-sideline-enable nil
                    lsp-ui-sideline-show-diagnostics nil
                    ;; Enable useful doc features while keeping UI clean
                    lsp-ui-doc-enable t
                    lsp-ui-doc-show-with-cursor nil     ; Don't show on cursor hover
                    lsp-ui-doc-show-with-mouse t        ; Show on mouse hover
                    lsp-ui-doc-delay 0.5                ; Small delay for docs
                    lsp-ui-doc-max-height 20            ; Reasonable doc window size
                    lsp-ui-doc-max-width 80
                    ;; Peek window settings
                    lsp-ui-peek-always-show nil      ; Jump directly with single candidate
                    lsp-ui-peek-list-width 40
                    lsp-ui-peek-peek-height 15)
      :bind (:map
             lsp-mode-map
             ([remap xref-find-definitions] . #'lsp-ui-peek-find-definitions)
             ([remap xref-find-references] . #'lsp-ui-peek-find-references)
             ;; Additional useful bindings
             ("C-c l D" . #'lsp-ui-doc-show)         ; Show docs on demand
             ("C-c l i" . #'lsp-ui-imenu))           ; LSP imenu
      :config
      ;; Add which-key descriptions for LSP UI commands
      (with-eval-after-load 'which-key
        (which-key-add-key-based-replacements
          "C-c l D" "show documentation"
          "C-c l i" "imenu (LSP)")))
#+end_src

**** Consult-LSP Integration

Consult-LSP provides enhanced LSP commands with live preview and better integration
with the modern completion stack, replacing the functionality previously provided by lsp-ivy.

#+begin_src emacs-lisp
  (use-package consult-lsp
    :defer t
    :bind (:map lsp-mode-map
           ("C-c l s" . consult-lsp-symbols)     ; LSP symbols
           ("C-c l d" . consult-lsp-diagnostics) ; Project diagnostics
           ("C-c l f" . consult-lsp-file-symbols)) ; File symbols
    :config
    ;; Add xref integration for workspace symbol navigation
    (advice-add 'consult-lsp-symbols :before
                (lambda (&rest _) (xref-push-marker-stack)))

    ;; Add which-key descriptions for consult-lsp commands
    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c l s" "workspace symbols"
        "C-c l d" "diagnostics"
        "C-c l f" "file symbols")))

  ;; Enhanced M-T binding with fallback to project-wide search
  (defun mvh/workspace-symbols-or-search ()
    "Search workspace symbols via LSP if available, otherwise fall back to project grep."
    (interactive)
    (xref-push-marker-stack)
    (if (and (bound-and-true-p lsp-mode)
             (lsp-workspaces))
        (consult-lsp-symbols)
      (let ((term (thing-at-point 'symbol)))
        (consult-ripgrep (projectile-project-root) term))))

  (global-set-key (kbd "M-T") 'mvh/workspace-symbols-or-search)
#+end_src

While we're on ~xref~ and stuff. Let's also make is so that searching
adds the point we're left on to the xref stack.

#+begin_src emacs-lisp
  (advice-add 'isearch-forward :before (lambda (arg1 arg2) (xref-push-marker-stack)))
  (advice-add 'isearch-backward :before (lambda (arg1 arg2) (xref-push-marker-stack)))
#+end_src

*** DAP (Debug Adapter Protocol)

DAP mode provides a modern debugging interface for multiple languages through the Debug
Adapter Protocol. For C/C++ development, it integrates with gdb/lldb and provides:
- Visual breakpoint management
- Step through code execution
- Variable inspection and watch expressions
- Stack frame navigation
- Debug console for REPL-style debugging

The configuration includes sensible defaults optimized for C debugging with gdb,
including automatic installation of debug adapters when needed.

All debug operations use the ~C-c d~ prefix, making them easy to discover via which-key.
The debug UI is configured to use side windows that don't disrupt your main editing layout.

#+begin_src emacs-lisp
  (use-package dap-mode
    :after lsp-mode
    :commands (dap-debug dap-debug-edit-template)
    :init
    (setq dap-auto-configure-features '(sessions locals controls tooltip))
    :config
    (require 'dap-gdb-lldb)

    (dap-register-debug-template
     "GDB::Run"
     (list :type "gdb"
           :request "launch"
           :name "GDB::Run"
           :target nil
           :cwd nil))

    (dap-register-debug-template
     "CRuby::Test"
     (list :type "gdb"
           :request "launch"
           :name "CRuby Test"
           :target "./miniruby"
           :cwd "${workspaceFolder}"
           :args (list "-I./lib" "-I." "-I.ext/common" "./tool/runruby.rb"
                       "--archdir=." "--extout=.ext" "test.rb")))

    (setq dap-ui-buffer-configurations
          '((dap-ui-locals-buffer . ((side . right) (slot . 1) (window-width . 0.30)))
            (dap-ui-expressions-buffer . ((side . right) (slot . 2) (window-width . 0.30)))
            (dap-ui-sessions-buffer . ((side . right) (slot . 3) (window-width . 0.30)))
            (dap-ui-breakpoints-buffer . ((side . left) (slot . 1) (window-width . 0.20)))
            (dap-ui-repl-buffer . ((side . bottom) (slot . 1) (window-height . 0.25)))))

    (setq dap-tooltip-mode t)

    (add-hook 'dap-stopped-hook
              (lambda (arg) (call-interactively #'dap-hydra)))

    :bind
    (("C-c d d" . dap-debug)
     ("C-c d e" . dap-debug-edit-template)
     ("C-c d l" . dap-debug-last)
     ("C-c d r" . dap-debug-recent)
     :map dap-mode-map
     ("C-c d h" . dap-hydra)
     ("C-c d b" . dap-breakpoint-toggle)
     ("C-c d B" . dap-breakpoint-condition)
     ("C-c d n" . dap-next)
     ("C-c d s" . dap-step-in)
     ("C-c d o" . dap-step-out)
     ("C-c d c" . dap-continue)
     ("C-c d q" . dap-disconnect)
     ("C-c d Q" . dap-delete-all-sessions)
     ("C-c d i" . dap-ui-inspect-thing-at-point)
     ("C-c d w" . dap-ui-expressions-add)
     ("C-c d W" . dap-ui-expressions-remove))

    :config
    (dap-ui-mode 1)

    (with-eval-after-load 'which-key
      (which-key-add-key-based-replacements
        "C-c d" "debug"
        "C-c d d" "start debug"
        "C-c d e" "edit template"
        "C-c d l" "debug last"
        "C-c d r" "debug recent"
        "C-c d h" "hydra menu"
        "C-c d b" "toggle breakpoint"
        "C-c d B" "conditional breakpoint"
        "C-c d n" "next line"
        "C-c d s" "step in"
        "C-c d o" "step out"
        "C-c d c" "continue"
        "C-c d q" "disconnect"
        "C-c d Q" "quit all sessions"
        "C-c d i" "inspect"
        "C-c d w" "add watch"
        "C-c d W" "remove watch")))
#+end_src

*** AI Assistant (Claude Code)

Claude Code IDE provides integration with the Claude CLI for AI-powered coding assistance within Emacs.

First, we need to ensure all dependencies are available:

#+begin_src emacs-lisp
  ;; Required dependencies
  (use-package websocket)
  (use-package transient)
  (use-package web-server)  ; Required for MCP tools server
#+end_src

Now we can set up Claude Code IDE with a minimal configuration:

#+begin_src emacs-lisp
  (use-package claude-code-ide
    :straight (:type git :host github :repo "manzaltu/claude-code-ide.el")
    :commands (claude-code-ide claude-code-ide-menu)
    :config
    ;; Enable MCP tools server
    (require 'claude-code-ide-emacs-tools)
    (setq claude-code-ide-enable-mcp-server t)
    (claude-code-ide-emacs-tools-setup)
    ;; Optional: Set window to right side at 50% width
    (setq claude-code-ide-use-side-window t
          claude-code-ide-window-position 'right
          claude-code-ide-window-width (/ (frame-width) 2))
    ;; Disable line numbers in Claude buffers
    (add-hook 'vterm-mode-hook
              (lambda ()
                (when (string-match-p "^\\*claude-code\\[" (buffer-name))
                  (display-line-numbers-mode -1))))
    :bind
    (("C-c a a" . claude-code-ide)
     ("C-c a m" . claude-code-ide-menu)))
#+end_src

** Language Modes

*** Ruby

Some of the codebases I use often require frozen strings. So this convenience
function will add the magic header if it's not already there.

#+begin_src emacs-lisp
  (defun ruby-frozen-string-literal ()
    "Check the current buffer for the magic comment # frozen_string_literal: true.
  If the comment doesn't exist, offer to insert it."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (unless (string= (thing-at-point 'line)
                       "# frozen_string_literal: true\n")
        (insert "# frozen_string_literal: true\n\n"))))
#+end_src

I use chruby to manage my Ruby versions. It's simple and works well with
.ruby-version files to automatically switch Ruby versions per project.

The chruby configuration includes:
- Automatic Ruby version switching based on .ruby-version files
- PATH management to ensure gem executables are found after version switches
- Support for a default Ruby version from ~/.ruby-version
- High-priority hooks to ensure chruby activates before LSP and other tools

The `mvh/update-gem-path-for-chruby` function ensures that after switching
Ruby versions, the gem bin directories are added to Emacs' PATH. This is
crucial for finding executables like ruby-lsp that are installed per Ruby version.

For ruby-lsp specifically, we use a wrapper script approach to ensure it can
always be found regardless of when LSP mode tries to start it. The wrapper
script sources chruby before executing ruby-lsp, ensuring the correct Ruby
version is active.

I also use minitest for testing.

#+begin_src emacs-lisp
  (use-package chruby
    :defer t  ; Load on demand, not immediately
    :init
    ;; Initialize chruby paths - this enables chruby integration
    (setq chruby-mode t)
    :config
    ;; Cache variables to avoid repeated shell commands
    (defvar mvh/chruby-cache (make-hash-table :test 'equal)
      "Cache for Ruby version gem paths to avoid repeated shell commands.")

    (defvar mvh/ruby-version-cache (make-hash-table :test 'equal)
      "Cache for .ruby-version file contents.")

    ;; Function to update PATH with gem bin directories - now with caching
    (defun mvh/update-gem-path-for-chruby ()
      "Update PATH to include gem bin directories for the current Ruby.
Uses caching to avoid repeated shell commands for the same Ruby version."
      (when-let ((ruby-path (executable-find "ruby")))
        ;; Check if we already have this Ruby's paths cached
        (let ((cached-paths (gethash ruby-path mvh/chruby-cache)))
          (if cached-paths
              ;; Use cached paths
              (progn
                (when (car cached-paths)
                  (add-to-list 'exec-path (car cached-paths))
                  (setenv "PATH" (concat (car cached-paths) ":" (getenv "PATH"))))
                (when (cdr cached-paths)
                  (add-to-list 'exec-path (cdr cached-paths))
                  (setenv "PATH" (concat (cdr cached-paths) ":" (getenv "PATH")))))
            ;; Not cached, fetch and cache (only happens once per Ruby version)
            (let* ((gem-info (shell-command-to-string "ruby -e 'puts Gem.user_dir; puts Gem.default_dir'"))
                   (gem-lines (split-string gem-info "\n" t))
                   (gem-user-dir (car gem-lines))
                   (gem-default-dir (cadr gem-lines))
                   user-bin default-bin)
              ;; Process user gem directory
              (when gem-user-dir
                (setq user-bin (expand-file-name "bin" gem-user-dir))
                (when (file-directory-p user-bin)
                  (add-to-list 'exec-path user-bin)
                  (setenv "PATH" (concat user-bin ":" (getenv "PATH")))))
              ;; Process default gem directory
              (when gem-default-dir
                (setq default-bin (expand-file-name "bin" gem-default-dir))
                (when (file-directory-p default-bin)
                  (add-to-list 'exec-path default-bin)
                  (setenv "PATH" (concat default-bin ":" (getenv "PATH")))))
              ;; Cache the paths for this Ruby
              (puthash ruby-path (cons user-bin default-bin) mvh/chruby-cache))))))

    ;; Auto-detect Ruby version from .ruby-version files with caching
    (defun mvh/chruby-use-corresponding ()
      "Use chruby to activate the Ruby version specified in .ruby-version.
Caches file contents to avoid repeated file reads."
      (when-let ((ruby-version-file (locate-dominating-file default-directory ".ruby-version")))
        (let* ((file-path (expand-file-name ".ruby-version" ruby-version-file))
               (file-mtime (nth 5 (file-attributes file-path)))
               (cached-data (gethash file-path mvh/ruby-version-cache))
               ruby-version)
          ;; Check cache validity
          (if (and cached-data
                   (equal (car cached-data) file-mtime))
              ;; Use cached version
              (setq ruby-version (cdr cached-data))
            ;; Read file and update cache
            (setq ruby-version (with-temp-buffer
                                (insert-file-contents file-path)
                                (string-trim (buffer-string))))
            (puthash file-path (cons file-mtime ruby-version) mvh/ruby-version-cache))
          ;; Only switch Ruby if needed
          (when (and ruby-version
                    (not (string-empty-p ruby-version))
                    (not (string= ruby-version (chruby-current))))
            (chruby ruby-version)
            (mvh/update-gem-path-for-chruby)))))

    ;; Simplified setup - no debug messages for performance
    (defun mvh/ruby-mode-chruby-setup ()
      "Setup chruby for Ruby mode efficiently."
      (mvh/chruby-use-corresponding))

    ;; Add with high priority (negative depth) to run early
    (add-hook 'ruby-mode-hook 'mvh/ruby-mode-chruby-setup -90)
    (add-hook 'enh-ruby-mode-hook 'mvh/ruby-mode-chruby-setup -90)
    (add-hook 'projectile-after-switch-project-hook 'mvh/chruby-use-corresponding)

    ;; Initialize chruby with default Ruby if available
    (when (file-exists-p (expand-file-name ".ruby-version" "~"))
      (let ((default-ruby (with-temp-buffer
                            (insert-file-contents (expand-file-name ".ruby-version" "~"))
                            (string-trim (buffer-string)))))
        (when (and default-ruby (not (string-empty-p default-ruby)))
          (chruby default-ruby)
          (mvh/update-gem-path-for-chruby)))))

  (use-package minitest :ensure t)
#+end_src

Ruby support is handled by enh-ruby-mode, which provides excellent syntax highlighting,
smart indentation with built-in toggling between deep and shallow styles, and mature
tooling that works reliably with LSP and other Ruby tools.

#+begin_src emacs-lisp
  ;; Use enh-ruby-mode for superior Ruby editing experience
  (use-package enh-ruby-mode
    :mode ("\\(\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
           . enh-ruby-mode)
    :hook (enh-ruby-mode . subword-mode)
    :config
    ;; Disable encoding magic comments
    (setq enh-ruby-add-encoding-comment-on-save nil)

    ;; Enable the built-in indent bouncing - press TAB repeatedly to toggle
    (setq enh-ruby-bounce-deep-indent t)

    ;; Set hanging brace indent level
    (setq enh-ruby-hanging-brace-indent-level 2)

    ;; Start with shallow indenting by default
    (setq enh-ruby-deep-indent-construct nil)

    ;; Enable case-insensitive search in Ruby buffers
    (add-hook 'enh-ruby-mode-hook (lambda () (setq case-fold-search t)))

    ;; Configure indentation
    (setq enh-ruby-indent-level 2)
    (setq enh-ruby-indent-tabs-mode nil))
#+end_src

With enh-ruby-mode, you get native support for toggling between deep and shallow
indentation styles - just press TAB when your cursor is on an already-indented line
to bounce between styles.

**Deep indentation**:
```ruby
test_var = if condition
             "yes"
           else
             "no"
           end
```

**Shallow indentation**:
```ruby
test_var = if condition
  "yes"
else
  "no"
end
```
*** C

The Ruby core team maintain an emacs style mode inside the main CRuby source
tree to help format the Ruby codebase according to their programming style
(which as far as I can tell is a mix of K&R and GNU).

If I have a Ruby checkout in the standard place I keep my source files, then we
should require the ruby-style file.

#+begin_src emacs-lisp
  (let ((ruby-misc-dir "~/git/ruby/misc"))
    (if (file-directory-p ruby-misc-dir)
        (progn
          (add-to-list 'load-path ruby-misc-dir)
          (require 'ruby-style))))
#+end_src

Also add a hook to ~cc-mode~ that sets up the comment/uncomment toggle
shortcut key, because by default it's bound to comment region only and
there's no shortcut for uncommenting a region, which is bonkers.

#+begin_src emacs-lisp
  (defun mvh/prog-mode-hook ()
    (define-key c-mode-map (kbd "C-c C-c") 'comment-or-uncomment-region))
  (add-hook 'c-initialization-hook 'mvh/prog-mode-hook)
#+end_src

#+begin_src emacs-lisp
  (defun cruby/compile-command ()
    "Returns a String representing the compile command to run for the given context"
    "make miniruby")

  (defun cruby/test-command ()
    "Returns a String representing the test command to run for the given context"
    (cond
     ((eq major-mode 'c-mode) "make btest")
     ((eq major-mode 'ruby-ts-mode)
      (format "make test-all TESTS=\"%s\"" (buffer-file-name)))
     ))

  ;; Declare function to avoid warnings
  (declare-function projectile-register-project-type "projectile")

  ;; Register project type after projectile is loaded
  (with-eval-after-load 'projectile
    (projectile-register-project-type 'cruby '("ruby.c" "kernel.rb" "yjit.c" )
                                      :compile 'cruby/compile-command
                                      :test 'cruby/test-command))

(use-package meson-mode)
#+end_src

*** Rust

- [ ] Remove or explain the cargo-culted rustic-mode-hook

This section sets up defaults for programming in Rust. I'm using
rustic-mode. With a few keybindings to tie in to specific functions in lsp-mode
(defined further up).

Most of the useful stuff is actually defined in the lsp-mode section.

The configuration includes which-key descriptions for the C-c C-c prefix to make
Rust-specific commands more discoverable.

#+begin_src emacs-lisp
  (use-package rustic
    :bind (:map rustic-mode-map
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c s" . lsp-rust-analyzer-status))
    :config (setq lsp-enable-symbol-highlighting nil
                  lsp-signature-auto-activate nil
                  rustic-format-on-save nil)
            (add-hook 'rustic-mode-hook 'mvh/rustic-mode-hook)

            ;; Add which-key descriptions for Rust commands
            (with-eval-after-load 'which-key
              (which-key-add-major-mode-key-based-replacements 'rustic-mode
                "C-c C-c" "rust commands"
                "C-c C-c a" "code action"
                "C-c C-c r" "rename symbol"
                "C-c C-c s" "analyzer status")))

  (defun mvh/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but
    ;; don't try to save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved
    ;; this should no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t)))
#+end_src

*** R

I use R generally for a bit of light stats munging. These days its mostly taking
benchmark results of perf numbers of the Ruby VM and visualising them.

#+begin_src emacs-lisp
  (use-package ess
    :defer t)
#+end_src

*** Web (js/html/css)

I don't do much web stuff anymore so this may not be the most up to date way of
handling this. I basically just bring in web-mode by default for a bunch of
files that look a lot like they could be web adjacent and configure a consistent
4 space indent.

#+begin_src emacs-lisp
  (use-package web-mode
    :mode "\\.tsx"
          "\\.erb"
          "\\.jsx"
          "\\.html"
          "\\.css"
          "\\.scss"
          "\\.sass"
    :init (setq web-mode-markup-indent-offset 2)
          (setq web-mode-css-indent-offset 2)
          (setq web-mode-code-indent-offset 2)
          (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
          (setq web-mode-enable-auto-indentation 1))
#+end_src

*** Zig

An experiment with Zig.

#+begin_src emacs-lisp
  (use-package zig-mode
    :defer t)
#+end_src

*** Markup (Markdown/toml/yaml)

Import the packages and associate the right file types required to write content
in Markdown, Toml and Yaml.

I also configure a default stylesheet here for previewing Markdown documents in
HTML. Leaving everything up to the browser really doesn't do our documents any
favours.

#+begin_src emacs-lisp

  (setq markdown-preview-stylesheets
        (list "http://thomasf.github.io/solarized-css/solarized-light.min.css"))

  (use-package toml-mode
    :mode "\\.toml")

  (use-package yaml-mode
    :mode "\\.yml"
          "\\.yaml")

  (use-package markdown-mode
    :mode "\\.md"
          "\\.markdown")

#+end_src

** Org Mode

The org mode package has already been installed from the package repos in the
early-init file, so that we could use the latest version to tangle this file
into the standard init file init.el.

Org mode is then specified again here, so that we can define some more thorough
initialisation on the package and set some custom variables.

The main ones defined here are the shift hooks. Setting these to the windmove
functions, means that org-mode window switching behaviour is much more
consistent with the rest of my emacs, which also has windmove enabled.

Now I can move windows with shift+arrows no matter the buffer type

#+begin_src emacs-lisp
    (use-package org-make-toc
      :hook org-mode)
    (use-package org
      :config (setq org-startup-truncated 1
                    org-log-done 1)
              (add-to-list 'org-modules 'org-tempo t)

              (add-hook 'org-shiftup-final-hook 'windmove-up)
              (add-hook 'org-shiftleft-final-hook 'windmove-left)
              (add-hook 'org-shiftdown-final-hook 'windmove-down)
              (add-hook 'org-shiftright-final-hook 'windmove-right)

              (org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)
                                                                       (emacs-lisp . t)
                                                                       (C . t)))
      :mode ("\\.org" . org-mode))
#+end_src

*** Quick notes (with Denote)

I often use the Apple Notes app to take super fast notes on stuff,
that I can look back on later, snippets of debug commands and whatnot.

I'd like to use Emacs to do this so I don't have to leave the editor
so I'm testing out ~denote~.

#+begin_src emacs-lisp
  (use-package denote
    :custom (denote-directory "~/git/notes/misc")
    :bind ("C-x C-n" . denote))
#+end_src

*** Journal

I also use org-journal to document my days. It's configured to start a new
journal file per day in a folder in my home directory.

Each new entry in the same day gets a new timestamped org mode heading in that
file.

#+begin_src emacs-lisp
    (use-package org-journal
      :defer t
      :init (setq org-journal-prefix-key "C-c j ")
      :custom (org-journal-dir "~/git/notes/log_book/")
              (org-journal-file-format "%Y/%m/%d")
              (org-journal-date-format "%A %d %b %Y")
              (org-agenda-files "~/Documents/org/"))
#+end_src

*** Blogging

The following section is an experiment to see whether I can configure and live
with a staticly generated blog/website entirely done within Emacs.

Currently my homepage uses Hugo and the process required to push a new post has
a high enough barrier to entry that I forget it every time, and it makes me want
to post less.

This is still **in progress**

#+begin_src emacs-lisp
  (use-package org-static-blog
    :defer t
    :init
    (setq org-static-blog-use-preview t
          org-static-blog-preview-convert-titles t
          org-static-blog-preview-ellipsis "..."
          org-static-blog-enable-tags t
          org-static-blog-publish-url "http://localhost:9090/"
          org-static-blog-publish-title "eightbitraptor.com"
          org-static-blog-posts-directory "~/src/org-blog/org/posts"
          org-static-blog-drafts-directory "~/src/org-blog/org/drafts/"
          org-static-blog-publish-directory "~/src/org-blog/")

    (setq org-static-blog-page-header
          (concat
           "<meta name=\"author\" content=\"eightbitraptor\">"
           "<meta name=\"referrer\" content=\"no-referrer\">"
           "<link href= \"/static/style.css\" rel=\"stylesheet\"
                  type=\"text/css\" />"
           "<link rel=\"icon\" href=\"static/favicon.ico\">")

          org-static-blog-page-preamble
          (concat
           "<div class=\"header\">"
           "  <a href=\"https://www.eightbitraptor.com\">eightbitraptor.com</a>"
           "  <div class=\"sitelinks\">"
           "    <a href=\"/blog/about.html\">about</a>"
           "    | <a href=\"/blog/software.html\">software</a>"
           "    | <a href=\"/blog/archive.html\">archive</a>"
           "    | <a href=\"/blog/rss.xml\">rss</a>"
           "  </div>"
           "</div>")))

  ;; Customize the HTML output
  (setq org-html-validation-link nil
        org-html-head-include-scripts nil
        org-html-head-include-default-style nil
        org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

  (setq org-publish-project-alist
        '(("orgfiles"
           :base-directory "~/org/"
           :base-extension "org"
           :publishing-directory "~/org/html"
           :publishing-function org-html-publish-to-html
           :headline-levels 3
           :section-numbers t
           :with-toc t
           :html-preamble t)

          ("images"
           :base-directory "~/org/images/"
           :base-extension "jpg\\|gif\\|png"
           :publishing-directory "~/org/html/images/"
           :publishing-function org-publish-attachment)

          ("other"
           :base-directory "~/org/other/"
           :base-extension "css\\|el"
           :publishing-directory "~/org/html/other/"
           :publishing-function org-publish-attachment)
          ("eightbitraptor" :components ("orgfiles" "images" "other"))))

#+end_src

** Audio

*** MPD client

Here we configure the built-in mpc-mode to connect to a running Mopidy server on
my home network desktop machine "senjougahara".

This relies on the following things:

- Mopidy is running with the MPD plugin on a host, using the default Mopidy port
- There is some way of mapping the hostname "senjougahara" to an IP. My network
  is small so I just use an entry in /etc/hosts for this.

MPC mode has a really weird UI. It _looks_ like it should behave like a "normal"
music player, it has selection windows for genre, artist, album etc. But there
doesn't seem to be any built in ways to manipulate the main playlist in MPD
beyond the standard mpc-add.

So there are a few helper functions in here that help to add groups of stuff to
the playlist, as well as remove things and clear down the playlist. All features
I use from ncmpcpp all the time.

I usually listen to Albums, so my workflow looks a bit like this:

- browse for the album I want
- press a to append it to the playlist
- press p to start playing (this toggles play/pause states)
- continue to add more albums as and when I feel like it.
- when I want a change, hit S to stop playing and clear the current playlist

  Soon I'll discover a simple way of selectively removing stuff from the
  playlist but I'm not quite there yet.

#+begin_src emacs-lisp
  (use-package mpc
    :defer t
    :init
    ;; Declare functions to avoid warnings
    (declare-function mpc-select-toggle "mpc")
    (declare-function mpc-playlist-add "mpc")
    (declare-function mpc-tagbrowser-all-p "mpc")
    (defun ebr/mpc-unselect-all (&optional event)
      "Unselect all selected songs in the current mpc buffer."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (cond
           ((get-char-property (point) 'mpc-select)
            (let ((ols nil))
              (dolist (ol mpc-select)
                (if (and (<= (overlay-start ol) (point))
                         (> (overlay-end ol) (point)))
                    (delete-overlay ol)
                  (push ol ols)))
              (cl-assert (= (1+ (length ols)) (length mpc-select)))
              (setq mpc-select ols)))
           ((mpc-tagbrowser-all-p) nil)
           (t nil))
          (forward-line 1))))
    (defun ebr/mpc-add-selected ()
      "Append to playlist, then unmark the song."
      (interactive)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    (defun ebr/mpc-add-at-point-and-unmark ()
      "Mark, append to playlist, then unmark the song."
      (interactive)
      (mpc-select-toggle)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    :custom
    (mpc-host "senjougahara")
    (mpc-songs-format "%2{Disc--}%3{Track} %28{Title} %18{Album} %18{Artist}")
    (mpc-browser-tags '(Artist Album))
    (mpc-cover-image-re "[Ff]older.jpg")
    :bind (:map mpc-mode-map
                ("a" . ebr/mpc-add-at-point-and-unmark)
                ("A" . ebr/mpc-add-selected)
                ("c" . ebr/mpc-unselect-all)
                ("d" . mpc-playlist-delete)
                ("p" . mpc-toggle-play)
                ("P" . mpc-playlist)
                ("s" . mpc-select)
                ("S" . mpc-stop))
    :config
    ;; Add which-key descriptions for MPC commands
    (with-eval-after-load 'which-key
      (which-key-add-major-mode-key-based-replacements 'mpc-mode
        "a" "add & unmark"
        "A" "add selected"
        "c" "clear selection"
        "d" "delete from playlist"
        "p" "play/pause"
        "P" "show playlist"
        "s" "select item"
        "S" "stop playback")))
#+end_src

** Emacs server

Finally we'll start a server attached to this GUI instance so that I
can use ~emacsclient~ in the terminal to open stuff in this instance.

#+begin_src emacs-lisp
  (use-package server
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src
