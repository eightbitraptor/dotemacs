#+TITLE Main Emacs Configuration File
#+AUTHOR Matthew Valentine-House
#+STARTUP overview

* Emacs config - eightbitraptor

This is the latest incarnation of my emacs config. It's been built up,
torn down, refactored and rebuilt many times since I started using
Emacs (the earliest reference I can find is a really ugly screenshot
of my work Mac circa 2011 - a long time before I knew remotely what I
was doing :|).

** Pre-initialisation (early-init.el)

This configuration uses straight.el as a package manager and org babel
to document the configuration. Alongside this file there is also an
early-init.el which Emacs will run before setting up the GUI and
before loading any other init files.

The early-init in this repo does a couple of things:

1. Uses straight.el for packaging. That is:
   - install the latest version of straight.el if it's not already
     installed
   - disable the built in package.el
   - install use-package and configure it to use straight.el by
     default
2. Install the latest version of org-mode, with no config, just to be
   able to tangle this file.

I install the latest version of org-mode in the early init, to avoid
any compatability problems later on when using straight.el to properly
configure org and some dependencies that I like to use.

*** Notes for initial setup

You should be able to clone this repo straight into ~/.emacs.d and
start Emacs and everything will be setup and configured on first
start. Although note that due to a lot of work being done in
early-init.el (including loading this file) the first startup will be
very slow as all the packages are git cloned from their various
repositories, but also that _the UI will not be running_

This may make it look like it didn't work, but check in htop/Task
Manager/whatever and you should see the process active and doing stuff
and eventually Emacs will appear. This will only happen on first boot.

I appreciate the UX for this is shit. But it only happens once per
machine, and well; It doesn't really bother me enough to fix it.

** Setting up the PATH

I like to make sure that Emacs is using the same PATH and Ruby paths
as my shell for consistency. This is important on macOS where
processes are started with a different environment.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns x))
    :init (setq exec-path-from-shell-variables '("PATH"
                                                 "MANPATH"
                                                 "GEM_HOME"
                                                 "GEM_PATH"))
          (setq exec-path-from-shell-check-startup-files nil)
          (exec-path-from-shell-initialize))
#+END_SRC

** No littering

No littering makes etc and var directories inside .emacs.d and
organises all the files that Emacs and other packages would otherwise
just dump directly into .emacs.d

#+BEGIN_SRC emacs-lisp
  (use-package no-littering :ensure t)
#+END_SRC

** Aesthetics

I like my editor to be nice to look at. So let's set up a few
frivolous things. First a nice theme

#+BEGIN_SRC emacs-lisp
  (use-package nord-theme
    :init (load-theme 'nord t))
#+END_SRC

Then nyan cat as a progress bar in my modeline

#+BEGIN_SRC emacs-lisp
  (use-package nyan-mode
    :init (nyan-mode))
#+END_SRC

Then solaire mode, which darkens windows that aren't directly
connected to an editor buffer. Think how VSCode has different coloured
backgrounds for the editor window and the filelist and you'll get the
idea.

#+BEGIN_SRC emacs-lisp
  (use-package solaire-mode
    :init (solaire-global-mode 1))
#+END_SRC

Silence the audible bell, and make the visual bell quite a bit more
subtle - just flash the text on the modeline white briefly, rather
than flashing the whole window.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function
      (lambda ()
        (let ((orig-fg (face-foreground 'mode-line)))
          (set-face-foreground 'mode-line "#FFFFFF")
          (run-with-idle-timer 0.1 nil
                               (lambda (fg) (set-face-foreground 'mode-line fg))
                               orig-fg))))
#+END_SRC

I like the cursor to be an I-beam, and I like to disable all the
toolbars and scrollbars for a pretty clean looking frame.

#+BEGIN_SRC emacs-lisp
  (setq-default cursor-type 'bar)
  (toggle-scroll-bar -1)
  (menu-bar-mode 0)
  (tool-bar-mode 0)
#+END_SRC

Don't display text in the startup buffer or the scratch buffer by default

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
#+END_SRC

Increase the line spacing a little from the default and turn on line
numbers globally.

#+BEGIN_SRC emacs-lisp
  (setq-default line-spacing 5)
  (global-display-line-numbers-mode t)
#+END_SRC

Now we'll configure the default fonts. We have to do this per OS
because everything renders fonts differently and at different sizes.

#+BEGIN_SRC emacs-lisp
  (cond ((eq (window-system) 'x)
         (set-face-attribute 'default nil :font "Jetbrains Mono 16"))
        ((eq (window-system) 'mac)
         (setq mac-frame-tabbing nil)
         (set-face-attribute 'default nil :font "Jetbrains Mono 18"))
        ((eq (window-system) 'w32)
         (set-face-attribute 'default nil :font "Consolas 16")))
#+END_SRC

** General Editor defaults

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

  (setq auto-save-default nil)
  (setq backup-directory-alist
        (list (cons "." (expand-file-name "backup" user-emacs-directory))))
  (setq make-backup-files nil)

  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))

  (fset 'yes-or-no-p 'y-or-n-p)

  (when window-system
    ((lambda ()
       (global-unset-key "\C-z")
       (global-unset-key "\C-x\C-z"))))

  (defun kill-other-buffers ()
    "Kill other buffers that are associated with files."
    (interactive)
    (mapc 'kill-buffer
          (delq (current-buffer)
                (remove nil (mapcar #'(lambda (b) (when (buffer-file-name b) b))
                                    (buffer-list))))))

  (defun open-line-above ()
    "Open a line above the line the point is at. Then move to that line and indent according to mode"
    (interactive)
    (indent-according-to-mode)
    (move-beginning-of-line 1)
    (newline)
    (previous-line)
    (indent-according-to-mode))
  (global-set-key (kbd "C-o") 'open-line-above)

  (defun duplicate-line (arg)
    "Duplicate current line, leaving point in lower line."
    (interactive "*p")
    ;; save the point for undo
    (setq buffer-undo-list (cons (point) buffer-undo-list))
    ;; local variables for start and end of line
    (let ((bol (save-excursion (beginning-of-line) (point)))
          eol)
      (save-excursion
        ;; don't use forward-line for this, because you would have
        ;; to check whether you are at the end of the buffer
        (end-of-line)
        (setq eol (point))

        ;; store the line and disable the recording of undo information
        (let ((line (buffer-substring bol eol))
              (buffer-undo-list t)
              (count arg))
          ;; insert the line arg times
          (while (> count 0)
            (newline)         ;; because there is no newline in 'line'
            (insert line)
            (setq count (1- count)))
          )

        ;; create the undo information
        (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
      ) ; end-of-let

    ;; put the point in the lowest line and return
    (next-line arg))
  (global-set-key (kbd "C-d") 'duplicate-line)

  (defun my-alter-frame-font-size (fn)
    (let* ((current-font-name (frame-parameter nil 'font))
           (decomposed-font-name (x-decompose-font-name current-font-name))
           (font-size (string-to-number (aref decomposed-font-name 5))))
      (aset decomposed-font-name 5 (number-to-string (funcall fn font-size)))
      (set-frame-font (x-compose-font-name decomposed-font-name))))

  (defun my-inc-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1+))

  (defun my-dec-frame-font-size ()
    (interactive)
    (my-alter-frame-font-size '1-))

  (global-set-key (kbd "C-+") 'my-inc-frame-font-size)
  (global-set-key (kbd "C-=") 'my-inc-frame-font-size)
  (global-set-key (kbd "C--") 'my-dec-frame-font-size)

  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)

  (global-set-key (kbd "s-<left>")  'shrink-window-horizontally)
  (global-set-key (kbd "s-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "s-<up>")    'enlarge-window)
  (global-set-key (kbd "s-<down>")  'shrink-window)

  (global-set-key (kbd "s-<return>") 'toggle-frame-fullscreen)

  (setq-default indent-tabs-mode nil)

  (setq-default c-basic-offset 4)
  (delete-selection-mode t)

  ;;; Navigation and Search

  (use-package which-key
    :config (which-key-mode)
            (setq which-key-idle-delay 3))

  (use-package undo-tree
    :config (global-undo-tree-mode))

  (use-package ag)
  (use-package crux
      :bind (("C-a" . crux-move-beginning-of-line)))
  (use-package flx)
  (use-package ivy-rich)
  (use-package counsel)

  (use-package ivy
    :init (setq ivy-use-virtual-buffers t
                ivy-sort-matches-functions-alist '((t . nil)
                                                   (ivy-completion-in-region . ivy--shorter-matches-first)
                                                   (execute-extended-command . ivy--shorter-matches-first)
                                                   (ivy-switch-buffer . ivy-sort-function-buffer)))
          (ivy-mode 1)
          (ivy-rich-mode 1))

  (use-package ivy-xref
    :init (when (>= emacs-major-version 27)
            (setq xref-show-definitions-function #'ivy-xref-show-defs))
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))

  (use-package imenu-list
    :bind ("C-c C-t" . imenu-list-smart-toggle))

  ;; Projectile spins trying to calculate what to write in the modeline when using TRAMP.
  ;; forcing a static modeline causes tramp mode to get fast again
  (use-package projectile
    :config (setq projectile-dynamic-mode-line nil)
            (projectile-global-mode)
    :bind-keymap ("C-c p" . projectile-command-map)
    :init (setq projectile-completion-system 'ivy))

  (use-package projectile-rails
    :config (projectile-rails-global-mode t))

  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))

  ;;; Code utilities (completion, whitespace management, Git etc)

  (use-package direnv
    :init (direnv-mode))

  (use-package editorconfig
    :init (editorconfig-mode 1))

  (use-package ws-butler
    :init (setq ws-butler-keep-whitespace-before-point nil)
    (ws-butler-global-mode))

  (use-package company
    :init (setq company-dabbrev-downcase 0)
          (setq company-idle-delay 0)
    :config (global-company-mode))

  (use-package company-box
    :hook (company-mode . company-box-mode))

  (setq vc-follow-symlinks t)
  (use-package magit
    :init (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
          (setq magit-push-current-set-remote-if-missing nil)
    :bind ("C-c s" . magit-status))
#+END_SRC

** Ruby

Some of the codebases I use often require frozen strings. So this
convenience function will add the magic header if it's not already
there.

#+BEGIN_SRC emacs-lisp
  (defun ruby-frozen-string-literal ()
    "Check the current buffer for the magic comment # frozen_string_literal: true.
  If the comment doesn't exist, offer to insert it."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (unless (string= (thing-at-point 'line)
                       "# frozen_string_literal: true\n")
        (insert "# frozen_string_literal: true\n\n"))))
#+END_SRC

I prefer to use rbenv to manage my Ruby versions, in conjunction with
ruby-build. rbenv is pretty easy to understand, and whilst I'm not
wild about the shims, it is working well for me.

I also use minitest for testing.

#+BEGIN_SRC
  (use-package rbenv
    :init (global-rbenv-mode)
          (rbenv-use-global))

  (use-package minitest :ensure t)
#+END_SRC

I use enh-ruby-mode instead of the built in ruby-mode. This is
entirely due to the existence of enh-ruby-bounce-deep-indent

ruby-mode's default behaviour is to do this:

#+BEGIN_SRC ruby :tangle no
  test_var = if condition
             "yes"
           else
             "no"
           end
#+END_SRC

Whereas enh-ruby-mode will let you toggle between that, and my
preferred format with another press of the tab key

#+BEGIN_SRC ruby :tangle no
  test_var = if condition
    "yes"
  else
    "no"
  end
#+END_SRC

There's a small amount of customisation happening here

- Make sure that we don't add encoding comments to our
  files. Generally I don't want anything in the git diff, other than
  what I'm explicitly changing.
- The magic enh-ruby-bounce-deep-indent as well as clearing out the
  list of deep indent constructs so that we default to my preferred
  way. Normally if, def, class and module are deep indented by default
- Turn on case-fold-search, this means that searching is basically
  case insensitive.
- Makes sure that Ruby mode is activated for things that might not
  look like Ruby files: rack configs, Rakefiles, Gemfiles etc.

And some other things that I need to look into

- [ ] Do I really want case-fold-search to be turned on?
- [ ] What does enh-ruby-hanging-brace-indent-level do?

#+BEGIN_SRC emacs-lisp
  (use-package enh-ruby-mode
    :mode "\\.rb"
          "\\Gemfile"
          "\\.ru"
          "\\Rakefile"
          "\\.rake"
    :hook (enh-ruby-mode . subword-mode)
    :config (setq ruby-insert-encoding-magic-comment nil
                  enh-ruby-add-encoding-comment-on-save nil
                  enh-ruby-bounce-deep-indent t
                  enh-ruby-deep-indent-construct nil
                  enh-ruby-hanging-brace-indent-level 2
                  case-fold-search t))
#+END_SRC

** C

The Ruby core team maintain an emacs style mode inside the main CRuby
source tree to help format the Ruby codebase according to their
programming style (which as far as I can tell is a mix of K&R and
GNU).

If I have a Ruby checkout in the standard place I keep my source
files, then we should require the ruby-style file.

#+BEGIN_SRC emacs-lisp
  (let ((ruby-misc-dir "~/src/ruby/misc"))
    (if (file-directory-p ruby-misc-dir)
        (progn
          (add-to-list 'load-path ruby-misc-dir)
          (require 'ruby-style))))
#+END_SRC

** LSP

LSP configuration is slightly frustrating, because due to the way
existence of a single lsp-client mode that talks to multiple
lsp-servers I need to configure the servers here.

This means that this lsp-mode config block contains config that's
relevant to multiple different languages. Predominantly C, Ruby and
Rust.

#+BEGIN_SRC emacs-lisp
   (setq lsp-client-packages '(lsp-solargraph lsp-clangd lsp-rust-analyzer))

  (use-package lsp-mode
    :config (setq lsp-idle-delay 0.1
                  lsp-headerline-breadcrumb-enable nil
                  lsp-enable-on-type-formatting nil
                  lsp-enable-indentation nil
                  lsp-solargraph-formatting nil
                  lsp-solargraph-diagnostics nil
                  lsp-diagnostics-provider nil
                  lsp-solargraph-hover nil
                  lsp-rust-analyzer-cargo-watch-command "clippy"
                  lsp-rust-analyzer-server-display-inlay-hints t)
            (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
    :hook ((c-mode . lsp)
           (c++-mode . lsp)
           (rustic-mode . lsp))
    :after (which-key)
    :bind-keymap ("M-l" . lsp-command-map))

  (use-package lsp-ivy
    :bind ("M-t" . 'lsp-ivy-workspace-symbol)
    :config (advice-add 'lsp-ivy--goto-symbol :before
                        (lambda (arg)
                          (xref-push-marker-stack))))

  (use-package ivy-xref
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))


  (use-package lsp-ui
    :config (setq lsp-ui-sideline-mode nil
                  lsp-ui-flycheck-live-reporting nil
                  lsp-ui-sideline-enable nil
                  lsp-ui-sideline-show-diagnostics nil)
    :bind (:map
           lsp-ui-mode-map
           ([remap xref-find-definitions] . #'lsp-ui-peek-find-definitions)
           ([remap xref-find-references] . #'lsp-ui-peek-find-references)))

  (use-package treemacs
    :init (with-eval-after-load 'winum
            (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config (progn
              (setq treemacs-litter-directories '("/node_modules" "/.venv" "/.cask"))
              (treemacs-follow-mode t)
              (treemacs-filewatch-mode t)
              (treemacs-fringe-indicator-mode 'always)
              (when treemacs-python-executable
                (treemacs-git-commit-diff-mode t))

              (pcase (cons (not (null (executable-find "git")))
                           (not (null treemacs-python-executable)))
                (`(t . t)
                 (treemacs-git-mode 'deferred))
                (`(t . _)
                 (treemacs-git-mode 'simple)))

              (treemacs-hide-gitignored-files-mode nil))
    :bind (:map global-map
                ("M-0"       . treemacs-select-window)
                ("C-x t 1"   . treemacs-delete-other-windows)
                ("C-x t t"   . treemacs)
                ("C-x t d"   . treemacs-select-directory)
                ("C-x t B"   . treemacs-bookmark)
                ("C-x t C-t" . treemacs-find-file)
                ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-projectile
    :after (treemacs projectile))

  (use-package treemacs-magit
    :after (treemacs magit))

  (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
    :after (treemacs persp-mode) ;;or perspective vs. persp-mode
    :config (treemacs-set-scope-type 'Perspectives))

  (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
    :after (treemacs)
    :config (treemacs-set-scope-type 'Tabs))

  (use-package lsp-treemacs
    :init (lsp-treemacs-sync-mode 1))
#+END_SRC

** Rust

- [ ] Remove or explain the cargo-culted rustic-mode-hook

This section sets up defaults for programming in Rust. I'm using
rustic-mode. With a few keybindings to tie in to specific functions in
lsp-mode (defined further up).

Most of the useful stuff is actually defined in the lsp-mode section.

#+BEGIN_SRC
  (use-package rustic
    :bind (:map rustic-mode-map
                ("C-c C-c a" . lsp-execute-code-action)
                ("C-c C-c r" . lsp-rename)
                ("C-c C-c s" . lsp-rust-analyzer-status))
    :config (setq lsp-eldoc-hook nil
                  lsp-enable-symbol-highlighting nil
                  lsp-signature-auto-activate nil
                  rustic-format-on-save nil)
            (add-hook 'rustic-mode-hook 'mvh/rustic-mode-hook))

  (defun mvh/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but
    ;; don't try to save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved
    ;; this should no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t)))
#+END_SRC

** Web Mode

I don't do much web stuff anymore so this may not be the most up to
date way of handling this. I basically just bring in web-mode by
default for a bunch of files that look a lot like they could be web
adjacent and configure a consistent 4 space indent.

#+BEGIN_SRC
  (use-package web-mode
    :mode "\\.tsx"
          "\\.erb"
          "\\.jsx"
          "\\.html"
          "\\.css"
          "\\.scss"
          "\\.sass"
    :init (setq web-mode-markup-indent-offset 4)
          (setq web-mode-css-indent-offset 4)
          (setq web-mode-code-indent-offset 4)
          (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
          (setq web-mode-enable-auto-indentation nil))
#+END_SRC

** Markup languages

Import the packages and associate the right file types required to
write content in Markdown, Toml and Yaml.

I also configure a default stylesheet here for previewing Markdown
documents in HTML. Leaving everything up to the browser really doesn't
do our documents any favours.

#+BEGIN_SRC emacs-lisp

  (setq markdown-preview-stylesheets
        (list "http://thomasf.github.io/solarized-css/solarized-light.min.css"))

  (use-package toml-mode
    :mode "\\.toml")

  (use-package yaml-mode
    :mode "\\.yml"
          "\\.yaml")

  (use-package markdown-mode
    :mode "\\.md"
          "\\.markdown")

#+END_SRC

** Org Mode for journalling and publishing

The org mode package has already been installed from the package repos
in the early-init file, so that we could use the latest version to
tangle this file into the standard init file init.el.

Org mode is then specified again here, so that we can define some more
thorough initialisation on the package and set some custom variables.

The main ones defined here are the shift hooks. Setting these to the
windmove functions, means that org-mode window switching behaviour is
much more consistent with the rest of my emacs, which also has
windmove enabled.

Now I can move windows with shift+arrows no matter the buffer type

#+BEGIN_SRC emacs-lisp
  ;;; Org Mode

  (use-package htmlize :ensure t)
  (use-package org
    :config (setq org-startup-truncated 1)
            (add-hook 'org-shiftup-final-hook 'windmove-up)
            (add-hook 'org-shiftleft-final-hook 'windmove-left)
            (add-hook 'org-shiftdown-final-hook 'windmove-down)
            (add-hook 'org-shiftright-final-hook 'windmove-right)
            (org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)))
    :mode ("\\.org" . org-mode))
#+END_SRC

I also use org-journal to document my days. It's configured to start a
new journal file per day in a folder in my home directory.

Each new entry in the same day gets a new timestamped org mode heading
in that file.

#+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :init (setq org-journal-prefix-key "C-c j ")
    :custom (org-journal-dir "~/Documents/log_books/")
            (org-journal-file-format "%Y%m%d")
            (org-journal-date-format "%A %d %b %Y"))
#+END_SRC

The following section is an experiment to see whether I can configure
and live with a staticly generated blog/website entirely done within
Emacs.

Currently my homepage uses Hugo and the process required to push a new
post has a high enough barrier to entry that I forget it every time,
and it makes me want to post less.

This is still **in progress**

#+BEGIN_SRC
  (use-package org-static-blog
    :init
    (setq org-static-blog-use-preview t
          org-static-blog-preview-convert-titles t
          org-static-blog-preview-ellipsis "..."
          org-static-blog-enable-tags t
          org-static-blog-publish-url "http://localhost:9090/"
          org-static-blog-publish-title "eightbitraptor.com"
          org-static-blog-posts-directory "~/src/org-blog/org/posts"
          org-static-blog-drafts-directory "~/src/org-blog/org/drafts/"
          org-static-blog-publish-directory "~/src/org-blog/")

    (setq org-static-blog-page-header
          (concat
           "<meta name=\"author\" content=\"eightbitraptor\">"
           "<meta name=\"referrer\" content=\"no-referrer\">"
           "<link href= \"/static/style.css\" rel=\"stylesheet\"
                  type=\"text/css\" />"
           "<link rel=\"icon\" href=\"static/favicon.ico\">")

          org-static-blog-page-preamble
          (concat
           "<div class=\"header\">"
           "  <a href=\"https://www.eightbitraptor.com\">eightbitraptor.com</a>"
           "  <div class=\"sitelinks\">"
           "    <a href=\"/blog/about.html\">about</a>"
           "    | <a href=\"/blog/software.html\">software</a>"
           "    | <a href=\"/blog/archive.html\">archive</a>"
           "    | <a href=\"/blog/rss.xml\">rss</a>"
           "  </div>"
           "</div>")))

  ;; Customize the HTML output
  (setq org-html-validation-link nil
        org-html-head-include-scripts nil
        org-html-head-include-default-style nil
        org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

  (setq org-publish-project-alist
        '(("orgfiles"
           :base-directory "~/org/"
           :base-extension "org"
           :publishing-directory "~/org/html"
           :publishing-function org-html-publish-to-html
           :headline-levels 3
           :section-numbers t
           :with-toc t
           :html-preamble t)

          ("images"
           :base-directory "~/org/images/"
           :base-extension "jpg\\|gif\\|png"
           :publishing-directory "~/org/html/images/"
           :publishing-function org-publish-attachment)

          ("other"
           :base-directory "~/org/other/"
           :base-extension "css\\|el"
           :publishing-directory "~/org/html/other/"
           :publishing-function org-publish-attachment)
          ("eightbitraptor" :components ("orgfiles" "images" "other"))))

#+END_SRC

** Music with MPC and MPD

Here we configure the built-in mpc-mode to connect to a running Mopidy
server on my home network desktop machine "senjougahara".

This relies on the following things:

- Mopidy is running with the MPD plugin on a host, using the default
  Mopidy port
- There is some way of mapping the hostname "senjougahara" to an
  IP. My network is small so I just use an entry in /etc/hosts for
  this.

MPC mode has a really weird UI. It _looks_ like it should behave like
a "normal" music player, it has selection windows for genre, artist,
album etc. But there doesn't seem to be any built in ways to
manipulate the main playlist in MPD beyond the standard mpc-add.

So there are a few helper functions in here that help to add groups of
stuff to the playlist, as well as remove things and clear down the
playlist. All features I use from ncmpcpp all the time.

I usually listen to Albums, so my workflow looks a bit like this:

- browse for the album I want
- press a to append it to the playlist
- press p to start playing (this toggles play/pause states)
- continue to add more albums as and when I feel like it.
- when I want a change, hit S to stop playing and clear the current
  playlist

  Soon I'll discover a simple way of selectively removing stuff from
  the playlist but I'm not quite there yet.

#+BEGIN_SRC emacs-lisp
  (use-package mpc
    :init
    (defun ebr/mpc-unselect-all (&optional event)
      "Unselect all selected songs in the current mpc buffer."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (cond
           ((get-char-property (point) 'mpc-select)
            (let ((ols nil))
              (dolist (ol mpc-select)
                (if (and (<= (overlay-start ol) (point))
                         (> (overlay-end ol) (point)))
                    (delete-overlay ol)
                  (push ol ols)))
              (cl-assert (= (1+ (length ols)) (length mpc-select)))
              (setq mpc-select ols)))
           ((mpc-tagbrowser-all-p) nil)
           (t nil))
          (forward-line 1))))
    (defun ebr/mpc-add-selected ()
      "Append to playlist, then unmark the song."
      (interactive)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    (defun ebr/mpc-add-at-point-and-unmark ()
      "Mark, append to playlist, then unmark the song."
      (interactive)
      (mpc-select-toggle)
      (mpc-playlist-add)
      (ebr/mpc-unselect-all))
    :custom
    (mpc-host "senjougahara")
    (mpc-songs-format "%2{Disc--}%3{Track} %28{Title} %18{Album} %18{Artist}")
    (mpc-browser-tags '(Artist Album))
    (mpc-cover-image-re "[Ff]older.jpg")
    :bind (:map mpc-mode-map
                ("a" . ebr/mpc-add-at-point-and-unmark)
                ("A" . ebr/mpc-add-selected)
                ("c" . ebr/mpc-unselect-all)
                ("d" . mpc-playlist-delete)
                ("p" . mpc-toggle-play)
                ("P" . mpc-playlist)
                ("s" . mpc-select)
                ("S" . mpc-stop)))
#+END_SRC
